<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2023/04/12/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>我的第一篇博客</title>
    <url>/2023/04/13/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<img src="E:/ftp%E8%B5%84%E6%96%99/note/8.SSM/1.Spring/%E8%AF%BE%E4%BB%B6/image/igeek.jpg" style="zoom:50%;" />

<h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><h1 id="一-Spring初识"><a href="#一-Spring初识" class="headerlink" title="一.Spring初识"></a>一.Spring初识</h1><h2 id="1-Spring是什么？"><a href="#1-Spring是什么？" class="headerlink" title="1.Spring是什么？"></a>1.Spring是什么？</h2><p>1.1 Spring是一个开源框架</p>
<p>1.2 Spring为简化企业级应用开发而生，使用Spring可以使简单的JavaBean实现以前只有EJB才能实现的功能</p>
<p>1.3 Spring是一个&#x3D;&#x3D;IOC反转控制&#x3D;&#x3D;和&#x3D;&#x3D;AOP面向切面编程&#x3D;&#x3D;容器框架</p>
<h2 id="x3D-x3D-2-具体描述Spring-x3D-x3D"><a href="#x3D-x3D-2-具体描述Spring-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;2.具体描述Spring&#x3D;&#x3D;"></a><strong>&#x3D;&#x3D;2.具体描述Spring&#x3D;&#x3D;</strong></h2><p>2.1 <strong>轻量级</strong>：并不是说Spring的jar包有多大，而是说Spring是非侵入性的（即当用Spring时，不需要去实现Spring给提供的任何接口，不需要去继承它的任何父类，可以享用它的功能）基于Spring开发的应用中的对象可以不依赖于Spring的API</p>
<p>2.2 <strong>依赖注入</strong>（DI—dependency  injection、IOC）</p>
<p>2.3 <strong>面向切面编程</strong>（AOP—aspect oriented programming）</p>
<p>2.4 <strong>容器</strong>：Spring是一个容器，因为它包含并且管理应用对象的生命周期</p>
<p>2.5 <strong>框架</strong>：Spring实现了使用简单的组件配置组合成一个复杂的应用。在Spring中可以使用XML和Java注解组合这些对象。</p>
<p>2.6 <strong>一站式</strong>：在IOC和AOP的基础上可以整合各种企业应用的开源框架（如Struts2、Hibernate、Mybatis）和优秀的第三方类库（实际上Spring自身也提供了展现层的Spring MVC和持久层的Spring JDBC）</p>
<h2 id="3-Spring-模块"><a href="#3-Spring-模块" class="headerlink" title="3.Spring 模块"></a>3.Spring 模块</h2><p>Spring官网： <a href="https://spring.io/">https://spring.io/</a></p>
<p>mvn仓库地址：<a href="https://mvnrepository.com/">https://mvnrepository.com/</a></p>
<p><img src="E:/ftp%E8%B5%84%E6%96%99/note/8.SSM/1.Spring/%E8%AF%BE%E4%BB%B6/image/1624203387935.bmp"> </p>
<blockquote>
<p>Core Container核心容器       </p>
<p>AOP  Aspects面向切面编程    </p>
<p>Instrumentation整合    </p>
<p>Messaging消息</p>
<p>Test 测试</p>
</blockquote>
<h2 id="4-搭建-Spring-开发环境"><a href="#4-搭建-Spring-开发环境" class="headerlink" title="4.搭建 Spring 开发环境"></a>4.搭建 Spring 开发环境</h2><p><strong>4.1  修改pom.xml文件，引入相关依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--  Spring依赖 --&gt;</span><br><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-beans --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-beans<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.3.13<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-context --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-context<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.3.13<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-core --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.3.13<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>



<p><strong>4.2 新建Spring 的配置文件</strong></p>
<p> 一个典型的 Spring 项目需要创建一个或多个 Bean 配置文件, 这些配置文件用于在 Spring IOC 容器里配置 Bean。</p>
<p> Bean 的配置文件可以放在 classpath下：</p>
<p><strong>新建resources文件夹</strong></p>
<p><img  src="E:/ftp%E8%B5%84%E6%96%99/note/8.SSM/1.Spring/%E8%AF%BE%E4%BB%B6/image/image-20200712232651926.png"  ><span class="image-caption">image-20200712232651926</span></p>
<p><strong>将resources文件夹设置为Resources Root</strong></p>
<p><img  src="E:/ftp%E8%B5%84%E6%96%99/note/8.SSM/1.Spring/%E8%AF%BE%E4%BB%B6/image/image-20200712232929343.png"  ><span class="image-caption">image-20200712232929343</span></p>
<p><strong>新建spring的核心配置文件，一般默认命名为applicationContext.xml</strong></p>
<p><img  src="E:/ftp%E8%B5%84%E6%96%99/note/8.SSM/1.Spring/%E8%AF%BE%E4%BB%B6/image/image-20200712233144462.png"  ><span class="image-caption">image-20200712233144462</span></p>
<p><img  src="E:/ftp%E8%B5%84%E6%96%99/note/8.SSM/1.Spring/%E8%AF%BE%E4%BB%B6/image/image-20200712233845544.png"  ><span class="image-caption">image-20200712233845544</span></p>
<h2 id="5-创建-HelloWorld-java"><a href="#5-创建-HelloWorld-java" class="headerlink" title="5.创建 HelloWorld.java"></a>5.创建 HelloWorld.java</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.cm.spring.ch01;<br><br><br><span class="hljs-keyword">import</span> org.springframework.context.ApplicationContext;<br><br><span class="hljs-keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">  IOC控制反转：</span><br><span class="hljs-comment">  	原来自己创建对象，现在可以通过Spring容器来创建对象，我们从中获取对象</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloWorld</span> &#123;<br><br>	<span class="hljs-keyword">private</span> String userName;<br><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setUserName1</span><span class="hljs-params">(String username)</span>&#123;<br><br>		System.out.println(<span class="hljs-string">&quot;setUserName1：&quot;</span>+username);<br><br>		<span class="hljs-built_in">this</span>.userName =  username;<br><br>	&#125;<br><br>	<span class="hljs-keyword">public</span> <span class="hljs-title function_">HelloWorld</span><span class="hljs-params">()</span>&#123;<br><br>		System.out.println(<span class="hljs-string">&quot;构造方法。。。&quot;</span>);<br><br>	&#125;<br><br> 	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hello</span><span class="hljs-params">()</span>&#123;<br><br>		System.out.println(<span class="hljs-string">&quot;Hello: &quot;</span>+userName);<br><br>	&#125;<br><br>&#125;<br><br><br></code></pre></td></tr></table></figure>



<h2 id="6-配置-applicationContext-xml"><a href="#6-配置-applicationContext-xml" class="headerlink" title="6.配置 applicationContext.xml"></a>6.配置 applicationContext.xml</h2><p>在 xml 文件中通过 bean 节点来配置 bean实例</p>
<p><strong>6.1 其中id是Bean 的名称</strong></p>
<p>1).在 IOC 容器中必须是唯一的</p>
<p>2).若 id 没有指定，Spring 自动将全类名作为 Bean 的名字</p>
<p>3).id 可以指定多个名字，名字之间可用逗号、分号、或空格分隔</p>
<p><strong>6.2 属性注入</strong></p>
<p>1).属性注入即通过 setter 方法注入Bean 的属性值或依赖的对象</p>
<p>2).属性注入使用 <property> 元素, 使用 name 属性指定 Bean 的属性名称，value 属性或 <value> 子节点指定属性值 </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag"></span><br><span class="hljs-tag">	<span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag"></span><br><span class="hljs-tag">	<span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span><br><br>	<span class="hljs-comment">&lt;!-- 配置bean --&gt;</span><br><br>	<span class="hljs-comment">&lt;!-- class属性值：全类名是通过反射的方式，由Spring创建的HelloWorld的对象</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">		id用来标识创建的对象	</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">		name对应的是setXxx()中的xxx</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">		value是指将为类中的属性赋值</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">	 --&gt;</span><br><br>	<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;helloWorld&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.igeek.spring.ch01.HelloWorld&quot;</span>&gt;</span><br><br>		<span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;userName1&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Spring&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><br>	<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure>



<h2 id="7-测试"><a href="#7-测试" class="headerlink" title="7.测试"></a>7.测试</h2><p>ApplicationContext 的主要实现类：ClassPathXmlApplicationContext：从类路径下加载配置文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainTest</span>&#123;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>		<span class="hljs-comment">//1.创建HelloWorld的一个对象</span><br><br>		<span class="hljs-comment">//HelloWorld h = new HelloWorld();</span><br><br>		<span class="hljs-comment">//2.为userName属性赋值</span><br><br>		<span class="hljs-comment">//h.setUserName(&quot;zhangsan&quot;);</span><br><br>		<span class="hljs-comment">//h.hello();</span><br><br><br><br>		<span class="hljs-comment">//1.创建Spring的IOC容器对象</span><br><br>		<span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">ctx</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;applicationContext.xml&quot;</span>);<br><br>		<span class="hljs-comment">//2.从IOC容器中获取Bean实例</span><br><br>		<span class="hljs-type">HelloWorld</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> (HelloWorld)ctx.getBean(<span class="hljs-string">&quot;helloWorld&quot;</span>);<br><br>		System.out.println(h);<br><br>		<span class="hljs-comment">//3.调用方法</span><br><br>		h.hello();<br><br>	&#125;<br>  <br>&#125;<br></code></pre></td></tr></table></figure>



<h1 id="二-Spring的IOC"><a href="#二-Spring的IOC" class="headerlink" title="二.Spring的IOC"></a>二.Spring的IOC</h1><h2 id="2-1、Spring-IOC-amp-DI概述"><a href="#2-1、Spring-IOC-amp-DI概述" class="headerlink" title="2.1、Spring_IOC&amp;DI概述"></a>2.1、Spring_IOC&amp;DI概述</h2><h3 id="x3D-x3D-1-IOC和DI概述-x3D-x3D"><a href="#x3D-x3D-1-IOC和DI概述-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;1.IOC和DI概述&#x3D;&#x3D;"></a>&#x3D;&#x3D;1.IOC和DI概述&#x3D;&#x3D;</h3><blockquote>
<p>&#x3D;&#x3D;IOC(Inversion of Control)&#x3D;&#x3D;：其思想是反转资源获取的方向. 传统的资源查找方式要求组件向容器发起请求查找资源. 作为回应, 容器适时的返回资源. 而应用了 IOC 之后, 则是容器主动地将资源推送给它所管理的组件, 组件所要做的仅是选择一种合适的方式来接受资源. 这种行为也被称为查找的被动形式。</p>
</blockquote>
<blockquote>
<p>&#x3D;&#x3D;DI(Dependency Injection)&#x3D;&#x3D; ：— IOC 的另一种表述方式：即组件以一些预先定义好的方式(例如: setter 方法)接受来自如容器的资源注入. 相对于 IOC 而言，这种表述更直接</p>
</blockquote>
<h3 id="2-IOC思想发展"><a href="#2-IOC思想发展" class="headerlink" title="2.IOC思想发展"></a>2.IOC思想发展</h3><p>需求: 生成 HTML 或 PDF 格式的不同类型的报表.</p>
<blockquote>
<p>IOC 前生 – 分离接口与实现：耦合度最高的方式，因为在报表服务类中需要知道接口及其每个实现类的细节</p>
</blockquote>
<p><img  src="E:/ftp%E8%B5%84%E6%96%99/note/8.SSM/1.Spring/%E8%AF%BE%E4%BB%B6/image/wps4.jpg"  ><span class="image-caption">img</span></p>
<blockquote>
<p>IOC 前生 – 采用工厂设计模式</p>
</blockquote>
<p><img  src="E:/ftp%E8%B5%84%E6%96%99/note/8.SSM/1.Spring/%E8%AF%BE%E4%BB%B6/image/wps5.jpg"  ><span class="image-caption">img</span></p>
<blockquote>
<p>IOC – 采用反转控制</p>
</blockquote>
<p><img  src="E:/ftp%E8%B5%84%E6%96%99/note/8.SSM/1.Spring/%E8%AF%BE%E4%BB%B6/image/wps7.jpg"  ><span class="image-caption">img</span></p>
<h2 id="x3D-x3D-2-2、如何定义Bean-x3D-x3D"><a href="#x3D-x3D-2-2、如何定义Bean-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;2.2、如何定义Bean&#x3D;&#x3D;"></a>&#x3D;&#x3D;2.2、如何定义Bean&#x3D;&#x3D;</h2><h3 id="1-BeanFactory"><a href="#1-BeanFactory" class="headerlink" title="1.BeanFactory"></a>1.BeanFactory</h3><p>BeanFactory表示Bean工厂，BeanFactory会负责创建Bean，并且提供获取Bean的API。而ApplicationContext继承了BeanFactory。</p>
<p>BeanFactory 是 Spring 框架的基础设施，面向 Spring 本身；ApplicationContext 面向使用 Spring 框架的开发者，几乎所有的应用场合都直接使用 ApplicationContext 而非底层的 BeanFactory。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//BeanFactory</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">BeanFactory</span> &#123;<br>    ...<br>&#125;<br><br><span class="hljs-comment">//ListableBeanFactory</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ListableBeanFactory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BeanFactory</span> &#123;<br>    ...<br>&#125;<br><br><span class="hljs-comment">//ApplicationContext</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ApplicationContext</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">EnvironmentCapable</span>, ListableBeanFactory, HierarchicalBeanFactory, MessageSource, ApplicationEventPublisher, ResourcePatternResolver &#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>



<blockquote>
<p>其中，在Spring源码中，BeanFactory接口存在一个非常重要的实现类是：<strong>DefaultListableBeanFactory</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DefaultListableBeanFactory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractAutowireCapableBeanFactoryimplements</span> ConfigurableListableBeanFactory, BeanDefinitionRegistry, Serializable &#123;<br>    <br>    <span class="hljs-comment">/** Map of bean definition objects, keyed by bean name. */</span><br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, BeanDefinition&gt; beanDefinitionMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="hljs-number">256</span>);<br>    <br>    <span class="hljs-comment">/** List of bean definition names, in registration order. */</span><br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> List&lt;String&gt; beanDefinitionNames = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(<span class="hljs-number">256</span>);<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="2-ApplicationContext"><a href="#2-ApplicationContext" class="headerlink" title="2.ApplicationContext"></a>2.ApplicationContext</h3><p>ApplicationContext是个接口，实际上也是一个BeanFactory，不过比BeanFactory更加强大</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//ApplicationContext</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ApplicationContext</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">EnvironmentCapable</span>, ListableBeanFactory, HierarchicalBeanFactory, MessageSource, ApplicationEventPublisher, ResourcePatternResolver &#123;<br>    ...<br>&#125;<br><br><span class="hljs-comment">//1. HierarchicalBeanFactory：拥有获取父BeanFactory的功能</span><br><span class="hljs-comment">//2. ListableBeanFactory：拥有获取beanNames的功能</span><br><span class="hljs-comment">//3. ResourcePatternResolver：资源加载器，可以一次性获取多个资源（文件资源等等）</span><br><span class="hljs-comment">//4. EnvironmentCapable：可以获取运行时环境（没有设置运行时环境功能）</span><br><span class="hljs-comment">//5. ApplicationEventPublisher：拥有广播事件的功能（没有添加事件监听器的功能）</span><br><span class="hljs-comment">//6. MessageSource：拥有国际化功能</span><br></code></pre></td></tr></table></figure>



<p>ApplicationContext 的主要实现类</p>
<blockquote>
<p>AnnotationConfigApplicationContext：通过加载配置类，获得上下文对象</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AnnotationConfigApplicationContext</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">GenericApplicationContext</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">AnnotationConfigRegistry</span> &#123;<br>    ...<br>&#125;<br><br><span class="hljs-comment">//1. ConfigurableApplicationContext：继承了ApplicationContext接口，增加了，添加事件监听器、添加BeanFactoryPostProcessor、设置Environment，获取ConfigurableListableBeanFactory等功能</span><br><span class="hljs-comment">//2. AbstractApplicationContext：实现了ConfigurableApplicationContext接口</span><br><span class="hljs-comment">//3. GenericApplicationContext：继承了AbstractApplicationContext，实现了BeanDefinitionRegistry接口，拥有了所有ApplicationContext的功能，并且可以注册BeanDefinition，注意这个类中有一个属性(private final DefaultListableBeanFactory beanFactory;)</span><br><span class="hljs-comment">//4. AnnotationConfigRegistry：可以单独注册某个为类为BeanDefinition（可以处理该类上的@Configuration注解，已经可以处理@Bean注解），同时可以扫描</span><br><span class="hljs-comment">//5. AnnotationConfigApplicationContext：继承了GenericApplicationContext，实现了AnnotationConfigRegistry接口，拥有了以上所有的功能</span><br></code></pre></td></tr></table></figure>



<blockquote>
<p>ClassPathXmlApplicationContext：从类路径下(bin目录下)加载XML配置文件</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractXmlApplicationContext</span> &#123;<br>    ...<br>&#125;<br><br><span class="hljs-comment">//它也间接继承了AbstractApplicationContext，但是相对于AnnotationConfigApplicationContext而言，功能没有AnnotationConfigApplicationContext强大，比如不能注册BeanDefinition </span><br><br></code></pre></td></tr></table></figure>



<h3 id="3-BeanDefinition"><a href="#3-BeanDefinition" class="headerlink" title="3.BeanDefinition"></a>3.BeanDefinition</h3><p>BeanDefinition表示Bean定义，BeanDefinition中存在很多属性用来描述一个Bean的特点。</p>
<blockquote>
<p>class，表示Bean类型</p>
<p>scope，表示Bean作用域，单例或原型等</p>
<p>lazyInit：表示Bean是否是懒加载</p>
<p>initMethodName：表示Bean初始化时要执行的方法</p>
<p>destroyMethodName：表示Bean销毁时要执行的方法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BeanDefinitionTest</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-comment">//1.获取IOC容器</span><br>        <span class="hljs-type">AnnotationConfigApplicationContext</span> <span class="hljs-variable">ac</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotationConfigApplicationContext</span>();<br><br>        <span class="hljs-comment">//2.通过BeanDefinition，直接注册实例bean，至IOC容器中</span><br>        <span class="hljs-type">AbstractBeanDefinition</span> <span class="hljs-variable">beanDefinition</span> <span class="hljs-operator">=</span> BeanDefinitionBuilder.genericBeanDefinition().getBeanDefinition();<br>        <span class="hljs-comment">//指定bean定义的类类型</span><br>        beanDefinition.setBeanClass(Person.class);<br>        <span class="hljs-comment">//将bean定义，注册至IOC容器中</span><br>        ac.registerBeanDefinition(<span class="hljs-string">&quot;p&quot;</span>,beanDefinition);<br>        <span class="hljs-comment">//刷新</span><br>        ac.refresh();<br><br>        <span class="hljs-comment">//3.获取实例bean</span><br>        <span class="hljs-type">Person</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> ac.getBean(<span class="hljs-string">&quot;p&quot;</span>, Person.class);<br>        System.out.println(p);<br><br>        <span class="hljs-comment">//4.使用实例bean</span><br>        p.setUsername(<span class="hljs-string">&quot;王朝&quot;</span>);<br>        System.out.println(p.getUsername());<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure>



<h3 id="4-FactoryBean"><a href="#4-FactoryBean" class="headerlink" title="4.FactoryBean"></a>4.FactoryBean</h3><p>1.Spring 中有两种类型的 Bean, 一种是普通Bean, 另一种是工厂Bean, 即FactoryBean. </p>
<p>2.工厂 Bean 跟普通Bean不同, 其返回的对象不是指定类的一个实例, 其返回的是该工厂 Bean 的 getObject 方法所返回的对象 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component(&quot;person&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyFactoryBean</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">FactoryBean</span> &#123;<br>    <span class="hljs-comment">//返回值，即注册在IOC容器中的实例</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getObject</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>    &#125;<br><br>    <span class="hljs-comment">//返回值，即注册在IOC容器中的实例的类类型</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Class&lt;?&gt; getObjectType() &#123;<br>        <span class="hljs-keyword">return</span> Person.class;<br>    &#125;<br><br>    <span class="hljs-comment">//是否是单例  true单例</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSingleton</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure>



<blockquote>
<p>若想独立创建一个Bean，也是可以通过FactoryBean来完成。但是注意，通过这种方式创造出来的Bean，<strong>只会经过初始化后</strong>，其他Spring的生命周期步骤是不会经过的，比如依赖注入。</p>
<p>通过@Bean也可以自己生成一个对象作为Bean，那么和FactoryBean的区别是什么呢？其实在很多场景下他俩是可以替换的，但是站在原理层面来说的，区别很明显，@Bean定义的Bean是会经过完整的Bean生命周期的。</p>
</blockquote>
<h3 id="5-函数式风格GenericApplicationContext"><a href="#5-函数式风格GenericApplicationContext" class="headerlink" title="5.函数式风格GenericApplicationContext"></a>5.函数式风格GenericApplicationContext</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//函数式风格创建对象，交给 spring 进行管理</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SupplierTest</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//1.先创建IOC容器</span><br>        <span class="hljs-type">AnnotationConfigApplicationContext</span> <span class="hljs-variable">ac</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotationConfigApplicationContext</span>();<br><br>        <span class="hljs-comment">//2.注册实例bean</span><br>        <span class="hljs-comment">//刷新</span><br>        ac.refresh();<br>        <span class="hljs-comment">//函数时编程风格Supplier，注册Person的实例bean</span><br>        ac.registerBean(<span class="hljs-string">&quot;ppp&quot;</span>, Person.class , ()-&gt;<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>());<br><br>        <span class="hljs-comment">//3.获取实例bean</span><br>        System.out.println(Arrays.toString(ac.getBeanDefinitionNames()));<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> ac.getBean(<span class="hljs-string">&quot;ppp&quot;</span>, Person.class);<br>        <span class="hljs-comment">//com.igeek.config.ch01.Person@887af79</span><br>        System.out.println(person);<br><br>        <span class="hljs-comment">//4.使用实例bean</span><br>        person.setUsername(<span class="hljs-string">&quot;马汉&quot;</span>);<br>        System.out.println(person.getUsername());<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure>



<h3 id="6-总结"><a href="#6-总结" class="headerlink" title="6.总结"></a>6.总结</h3><p>在Spring中，可以通过<strong>声明式定义Bean</strong>方式：</p>
<blockquote>
<p>方式一：<bean></p>
<p>方式二：@Bean</p>
<p>方式三：@Component、@Service、@Controller、@Repository</p>
</blockquote>
<p>在Spring中，可以通过<strong>编程式定义Bean</strong>方式：</p>
<blockquote>
<p>方式一：BeanDefinition 接口</p>
<p>方式二： 自定义FactoryBean </p>
<p>方式三：函数式接口 Supplier&lt;T&gt;</p>
</blockquote>
<h2 id="2-3、Spring-IOC-XML版"><a href="#2-3、Spring-IOC-XML版" class="headerlink" title="2.3、Spring IOC XML版"></a>2.3、Spring IOC XML版</h2><h3 id="1-依赖注入的方式"><a href="#1-依赖注入的方式" class="headerlink" title="1.依赖注入的方式"></a>1.依赖注入的方式</h3><h4 id="1-属性注入"><a href="#1-属性注入" class="headerlink" title="1).属性注入"></a>1).属性注入</h4><p>1).属性注入即通过 setter 方法注入Bean 的属性值或依赖的对象</p>
<p>2).属性注入使用 <property> 元素, 使用 name 属性指定 Bean 的属性名称，value 属性或 <value> 子节点指定属性值 </p>
<p>3).属性注入是实际应用中最常用的注入方式</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- name对应的是setXxx()中的xxx value是指将为类中的属性赋值--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;helloWorld&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.igeek.spring.ch01.HelloWorld&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;userName1&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Spring&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure>



<h4 id="2-构造方法注入"><a href="#2-构造方法注入" class="headerlink" title="2).构造方法注入"></a>2).构造方法注入</h4><p>1).通过构造方法注入Bean 的属性值或依赖的对象，它保证了 Bean 实例在实例化后就可以使用。</p>
<p>2).构造器注入在 <constructor-arg> 元素里声明属性, <constructor-arg> 中没有 name 属性</p>
<p>3). </p>
<p>按<strong>索引</strong>匹配入参：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;car2&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.igeek.xml.ch02.Car&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">index</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;玛莎拉蒂&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">index</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;3000000.0&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure>



<p>按<strong>类型</strong>匹配入参：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;p2&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.igeek.xml.ch02.Person&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;java.lang.String&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;李四&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;int&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;26&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;com.igeek.xml.ch02.Car&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;car2&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure>



<h3 id="2-属性配置细节"><a href="#2-属性配置细节" class="headerlink" title="2.属性配置细节"></a>2.属性配置细节</h3><h4 id="1-字面值"><a href="#1-字面值" class="headerlink" title="1).字面值"></a>1).字面值</h4><blockquote>
<p>字面值：可用字符串表示的值，可以通过 <value> 元素标签或 value 属性进行注入。</p>
<p>基本数据类型及其封装类、String 等类型都可以采取字面值注入的方式。</p>
<p>若字面值中包含特殊字符，可以使用 &#x3D;&#x3D;<![CDATA[]]>&#x3D;&#x3D;把字面值包裹起来。</p>
</blockquote>
<p><img  src="E:/ftp%E8%B5%84%E6%96%99/note/8.SSM/1.Spring/%E8%AF%BE%E4%BB%B6/image/wps9.jpg"  ><span class="image-caption">img</span></p>
<h4 id="2-引用其它-Bean"><a href="#2-引用其它-Bean" class="headerlink" title="2).引用其它 Bean"></a>2).引用其它 Bean</h4><blockquote>
<p>1). 组成应用程序的 Bean 经常需要相互协作以完成应用程序的功能。 要使 Bean 能够相互访问, 就必须在 Bean 配置文件中指定对 Bean 的引用。</p>
<p>2). 在 Bean 的配置文件中, 可以通过 <ref> 元素或 ref属性为 Bean 的属性或构造器参数指定对 Bean 的引用。</p>
<p>3).也可以在属性或构造器里包含 Bean 的声明, 这样的 Bean 称为内部 Bean.</p>
<blockquote>
<ul>
<li>当 Bean 实例仅仅给一个特定的属性使用时, 可以将其声明为内部 Bean. 内部 Bean 声明直接包含在 <property> 或 <constructor-arg> 元素里, 不需要设置任何 id 或 name 属性</li>
<li>内部 Bean 不能使用在任何其他地方</li>
</ul>
</blockquote>
</blockquote>
<p><img  src="E:/ftp%E8%B5%84%E6%96%99/note/8.SSM/1.Spring/%E8%AF%BE%E4%BB%B6/image/1624205450396.png"  ><span class="image-caption">1624205450396</span></p>
<h4 id="3-级联属性"><a href="#3-级联属性" class="headerlink" title="3).级联属性"></a>3).级联属性</h4><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;p&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.cm.ch02.ref.Person&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;李四&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;age&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;35&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;car&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;c&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">            通过级联属性操作修改车的价格</span><br><span class="hljs-comment">            1.等价于Person对象调用了setCar(),car对象调用了setPrice()</span><br><span class="hljs-comment">            2.属性需要先初始化赋值，否则会出现异常</span><br><span class="hljs-comment">        --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;car.price&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;500000&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;c&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.cm.ch02.ref.Car&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;label&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;aodi&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;price&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;300000&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br><br></code></pre></td></tr></table></figure>

<h4 id="4-集合属性"><a href="#4-集合属性" class="headerlink" title="4).集合属性"></a>4).集合属性</h4><blockquote>
<p>1.在 Spring中可以通过一组内置的 xml 标签(例如: <list>, <set> 或 <map>) 来配置集合属性.</p>
<p>2.配置 java.util.List 类型的属性, 需要指定 <list> 标签, 在标签里包含一些元素. 这些标签可以通过 <value> 指定简单的常量值, 通过 <ref> 指定对其他 Bean 的引用. 通过<bean> 指定内置 Bean 定义. 通过 <null/> 指定空元素. </p>
<p>3.数组的定义和 List 一样, 都使用 <list></p>
<p>4.配置 java.util.Set 需要使用 <set> 标签, 定义元素的方法与 List 一样.</p>
</blockquote>
<p><img  src="E:/ftp%E8%B5%84%E6%96%99/note/8.SSM/1.Spring/%E8%AF%BE%E4%BB%B6/image/1624205680085.png"  ><span class="image-caption">1624205680085</span></p>
<blockquote>
<p>5.Java.util.Map 通过 <map> 标签定义, <map> 标签里可以使用多个 <entry> 作为子标签. 每个条目包含一个键和一个值. </p>
<p>6.必须在 <key> 标签里定义键</p>
<p>7.因为键和值的类型没有限制, 所以可以自由地为它们指定 <value>, <ref>, <bean> 或 <null> 元素. </p>
<p>8.可以将 Map 的键和值作为 <entry> 的属性定义: 简单常量使用 key 和 value 来定义; Bean 引用通过 key-ref 和 value-ref 属性定义</p>
</blockquote>
<p><img  src="E:/ftp%E8%B5%84%E6%96%99/note/8.SSM/1.Spring/%E8%AF%BE%E4%BB%B6/image/1624205700321.png"  ><span class="image-caption">1624205700321</span></p>
<blockquote>
<p>9.使用 utility scheme 定义集合</p>
<p>1).使用基本的集合标签定义集合时, 不能将集合作为独立的 Bean 定义, 导致其他 Bean 无法引用该集合, 所以无法在不同 Bean 之间共享集合.</p>
<p>2).可以使用 util schema 里的集合标签定义独立的集合 Bean. 需要注意的是, 必须在 <beans> 根元素里添加 util schema 定义</p>
</blockquote>
<p><img  src="E:/ftp%E8%B5%84%E6%96%99/note/8.SSM/1.Spring/%E8%AF%BE%E4%BB%B6/image/1624206566669.png"  ><span class="image-caption">1624206566669</span></p>
<h4 id="5-p命名空间"><a href="#5-p命名空间" class="headerlink" title="5).p命名空间"></a>5).p命名空间</h4><blockquote>
<p>1.为了简化 XML 文件的配置，越来越多的 XML 文件采用属性而非子元素配置信息。</p>
<p>2.Spring 从 2.5 版本开始引入了一个新的 p 命名空间，可以通过 <bean> 元素属性的方式配置 Bean 的属性。</p>
<p>3.使用 p 命名空间后，基于 XML 的配置方式将进一步简化</p>
</blockquote>
<p><img  src="E:/ftp%E8%B5%84%E6%96%99/note/8.SSM/1.Spring/%E8%AF%BE%E4%BB%B6/image/1624206601107.png"  ><span class="image-caption">1624206601107</span></p>
<h3 id="3-Bean的作用域"><a href="#3-Bean的作用域" class="headerlink" title="3.Bean的作用域"></a>3.Bean的作用域</h3><table>
<thead>
<tr>
<th align="center">类别</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">singleton</td>
<td align="center">在 SpringlOC容器中仅存在一个Bean实例，Bean以单实例的方式存在</td>
</tr>
<tr>
<td align="center">prototype</td>
<td align="center">每次调用getBean()时都会返回一个新的实例</td>
</tr>
<tr>
<td align="center">request</td>
<td align="center">每次HTTP请求都会创建一个新的 Bean ，该作用域仅适用于WebApplicationContext环境</td>
</tr>
<tr>
<td align="center">session</td>
<td align="center">同一个HTTP Session共享一个Bean ，不同的HTTP Session使用不同的 Bean。该作用域仅适用于WebApplicationContext环境</td>
</tr>
</tbody></table>
<blockquote>
<p>1.在 Spring 中, 可以在 <bean> 元素的 &#x3D;&#x3D;scope&#x3D;&#x3D; 属性里设置 Bean 的作用域. </p>
<p>2.默认情况下, Spring 只为每个在 IOC 容器里声明的 Bean 创建唯一一个实例, 整个 IOC 容器范围内都能共享该实例：所有后续的 getBean() 调用和 Bean 引用都将返回这个唯一的 Bean 实例.该作用域被称为 singleton, 它是所有 Bean 的默认作用域.</p>
</blockquote>
<h3 id="4-外部属性文件"><a href="#4-外部属性文件" class="headerlink" title="4.外部属性文件"></a>4.外部属性文件</h3><p>1.在类路径下新建<strong>db.properties</strong>属性文件</p>
<p><img  src="E:/ftp%E8%B5%84%E6%96%99/note/8.SSM/1.Spring/%E8%AF%BE%E4%BB%B6/image/image-20200713001742668.png"  ><span class="image-caption">image-20200713001742668</span></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><code class="hljs properties"><span class="hljs-comment">#mysql</span><br><span class="hljs-attr">db.user</span>=<span class="hljs-string">root</span><br><span class="hljs-attr">db.password</span>=<span class="hljs-string">root</span><br><span class="hljs-attr">db.url</span>=<span class="hljs-string">jdbc:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=Asia/Shanghai</span><br><span class="hljs-attr">db.driverClass</span>=<span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br><span class="hljs-attr">db.maxPoolSize</span>=<span class="hljs-string">30</span><br><span class="hljs-attr">db.minPoolSize</span>=<span class="hljs-string">3</span><br><span class="hljs-attr">db.initialPoolSize</span>=<span class="hljs-string">5</span><br><span class="hljs-attr">db.acquireIncrement</span>=<span class="hljs-string">5</span><br></code></pre></td></tr></table></figure>



<p>2.修改pom.xml文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--mysql驱动包 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.0.16<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--c3p0 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>c3p0<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>c3p0<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.9.1.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br></code></pre></td></tr></table></figure>

<p>注意：根据当前安装的mysql版本，选择合适的mysql驱动的版本号</p>
<p>3.新建spring的核心配置文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 导入外部属性文件 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context:property-placeholder</span> <span class="hljs-attr">location</span>=<span class="hljs-string">&quot;classpath:db.properties&quot;</span> /&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 配置c3p0数据连接池 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 使用外部属性文件上的key --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;db.user&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;db.password&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;jdbcUrl&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;db.url&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driverClass&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;db.driverClass&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;maxPoolSize&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;db.maxPoolSize&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;minPoolSize&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;db.minPoolSize&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;initialPoolSize&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;db.initialPoolSize&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;acquireIncrement&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;db.acquireIncrement&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br><br></code></pre></td></tr></table></figure>



<p>4.测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.cm.ch03.properties;<br><br><span class="hljs-keyword">import</span> com.mchange.v2.c3p0.ComboPooledDataSource;<br><span class="hljs-keyword">import</span> org.springframework.context.ApplicationContext;<br><span class="hljs-keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;<br><br><span class="hljs-keyword">import</span> java.sql.Connection;<br><span class="hljs-keyword">import</span> java.sql.PreparedStatement;<br><span class="hljs-keyword">import</span> java.sql.ResultSet;<br><span class="hljs-keyword">import</span> java.sql.SQLException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainTest</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br><br>        <span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">ac</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;beans_properties.xml&quot;</span>);<br>        <span class="hljs-type">ComboPooledDataSource</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> (ComboPooledDataSource)ac.getBean(<span class="hljs-string">&quot;dataSource&quot;</span>);<br>        System.out.println(pool);<br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> pool.getConnection();<br>        <span class="hljs-type">PreparedStatement</span> <span class="hljs-variable">preparedStatement</span> <span class="hljs-operator">=</span> connection.prepareStatement(<span class="hljs-string">&quot;select * name from t_user where id=?&quot;</span>);<br>        preparedStatement.setInt(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>        <span class="hljs-type">ResultSet</span> <span class="hljs-variable">resultSet</span> <span class="hljs-operator">=</span> preparedStatement.executeQuery();<br>        <span class="hljs-keyword">while</span> (resultSet.next())&#123;<br>            System.out.println(resultSet.getString(<span class="hljs-number">1</span>));<br>        &#125;<br>        connection.close();<br>        pool.close();<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure>



<h3 id="5-指定扫描包"><a href="#5-指定扫描包" class="headerlink" title="5.指定扫描包"></a>5.指定扫描包</h3><p>当在组件类上使用了特定的注解之后, 还需要在 Spring 的配置文件中声明 &lt;context:component-scan&gt;表示要去扫描哪些包：</p>
<p>1).base-package 属性指定一个需要扫描的基类包，Spring 容器将会扫描这个基类包里及其子包中的所有类.</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span><br><br>	<span class="hljs-comment">&lt;!-- 指定Spring IOC容器扫描的包 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.cm.ch04&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">context:component-scan</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span> <br><br></code></pre></td></tr></table></figure>

<p>2).当需要扫描多个包时, 可以使用逗号分隔.</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 指定Spring IOC容器扫描的包，当有多个包时，则可使用逗号隔开 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.cm.ch04 , com.cm.ch02&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">context:component-scan</span>&gt;</span><br><br></code></pre></td></tr></table></figure>

<p>3).如果仅希望扫描特定的类而非基包下的所有类，可使用 resource-pattern 属性过滤特定的类.</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 指定Spring IOC容器扫描的包，通过resource-pattern指定扫描的资源 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.cm.ch04&quot;</span> <span class="hljs-attr">resource-pattern</span>=<span class="hljs-string">&quot;entity/*&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">context:component-scan</span>&gt;</span><br><br></code></pre></td></tr></table></figure>



<p>4).<strong>&lt;context:include-filter&gt;</strong> 子节点表示要包含的目标类</p>
<p><strong>&lt;context:exclude-filter&gt;</strong> 子节点表示要排除在外的目标类</p>
<p>&lt;context:component-scan&gt;下可以拥有若干个&lt;context:include-filter&gt; 和 &lt;context:exclude-filter&gt; 子节点。</p>
<p>&lt;context:include-filter&gt;和&lt;context:exclude-filter&gt;子节点支持多种类型的过滤表达式：</p>
<table>
<thead>
<tr>
<th align="center">类别</th>
<th align="center">示例</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">annotation</td>
<td align="center">org.springframework.stereotype.Xxx</td>
<td align="center">所有标注了Xxx的类。该类型采用目标类是否标注了某个注解进行过滤</td>
</tr>
<tr>
<td align="center">assinable</td>
<td align="center">com.igeek.XxxService</td>
<td align="center">所有继承或扩展XxxService的类。该类型采用目标类是否继承或扩展某个特定类进行过滤</td>
</tr>
<tr>
<td align="center">aspectj</td>
<td align="center">com.igeek..”Service“</td>
<td align="center">所有类名以 Service结束的类及继承或扩展它们的类。该类型采用AspejctJ表达式进行过滤</td>
</tr>
<tr>
<td align="center">regex</td>
<td align="center">com.\igeek.\anno\.*</td>
<td align="center">所有com.igeek.anno包下的类。该类型采用正则表达式根据类的类名进行过滤</td>
</tr>
<tr>
<td align="center">custom</td>
<td align="center">com.igeek.XxxTypeFilter</td>
<td align="center">采用XxxTypeFilter通过代码的方式定义过滤规则。该类必须实现org.springframework.core.type.TypeFilter接口</td>
</tr>
</tbody></table>
<p><img  src="E:/ftp%E8%B5%84%E6%96%99/note/8.SSM/1.Spring/%E8%AF%BE%E4%BB%B6/image/1624207675347.png"  ><span class="image-caption">1624207675347</span></p>
<p><img  src="E:/ftp%E8%B5%84%E6%96%99/note/8.SSM/1.Spring/%E8%AF%BE%E4%BB%B6/image/1624207684616.png"  ><span class="image-caption">1624207684616</span></p>
<h3 id="6-BeanPostProcessor"><a href="#6-BeanPostProcessor" class="headerlink" title="6.BeanPostProcessor"></a>6.BeanPostProcessor</h3><p>BeanPostProcessor表示Bean的后置处理器，我们可以定义一个或多个BeanPostProcessor。</p>
<p>一个BeanPostProcessor可以在<strong>任意一个Bean</strong>的<strong>初始化之前</strong>以及<strong>初始化之后</strong>去额外的做一些用户自定义的逻辑，当然，我们可以通过判断beanName来进行针对性处理（针对某个Bean，或某部分Bean）。</p>
<p>我们可以通过定义BeanPostProcessor来干涉Spring创建Bean的过程。</p>
<h4 id="1-Spring-IOC-容器对-Bean-的生命周期进行管理的过程"><a href="#1-Spring-IOC-容器对-Bean-的生命周期进行管理的过程" class="headerlink" title="1).Spring IOC 容器对 Bean 的生命周期进行管理的过程"></a>1).Spring IOC 容器对 Bean 的生命周期进行管理的过程</h4><blockquote>
<p>1).通过构造器或工厂方法创建 Bean 实例</p>
<p>2).为 Bean 的属性设置值和对其他 Bean 的引用</p>
<p>3).调用 Bean 的初始化方法</p>
<p>4).Bean 可以使用了</p>
<p>5).当容器关闭close时, 调用 Bean 的销毁方法</p>
</blockquote>
<p>在 Bean 的声明里设置 init-method 和 destroy-method 属性, 为 Bean 指定初始化和销毁方法.</p>
<p><img  src="E:/ftp%E8%B5%84%E6%96%99/note/8.SSM/1.Spring/%E8%AF%BE%E4%BB%B6/image/1624207142631.png"  ><span class="image-caption">1624207142631</span></p>
<h4 id="2-创建-Bean-后置处理器"><a href="#2-创建-Bean-后置处理器" class="headerlink" title="2).创建 Bean 后置处理器"></a>2).创建 Bean 后置处理器</h4><blockquote>
<p>1.Bean 后置处理器允许在调用初始化方法前后对 Bean 进行额外的处理.</p>
<p>2.Bean 后置处理器对 IOC 容器里的所有 Bean 实例逐一处理, 而非单一实例. 其典型应用是: 检查 Bean 属性的正确性或根据特定的标准更改 Bean 的属性.</p>
<p>3.对Bean 后置处理器而言, 需要实现**&#x3D;&#x3D;BeanPostProcessor接口&#x3D;&#x3D;**. 在初始化方法被调用前后, Spring 将把每个 Bean 实例分别传递给上述接口的以下两个方法:</p>
</blockquote>
<p><img  src="E:/ftp%E8%B5%84%E6%96%99/note/8.SSM/1.Spring/%E8%AF%BE%E4%BB%B6/image/1624207251843.png"  ><span class="image-caption">1624207251843</span></p>
<p><img  src="E:/ftp%E8%B5%84%E6%96%99/note/8.SSM/1.Spring/%E8%AF%BE%E4%BB%B6/image/1624207264116.png"  ><span class="image-caption">1624207264116</span></p>
<p><img  src="E:/ftp%E8%B5%84%E6%96%99/note/8.SSM/1.Spring/%E8%AF%BE%E4%BB%B6/image/1624207273596.png"  ><span class="image-caption">1624207273596</span></p>
<h4 id="3-添加-Bean-后置处理器后-Bean-的生命周期"><a href="#3-添加-Bean-后置处理器后-Bean-的生命周期" class="headerlink" title="3).添加 Bean 后置处理器后 Bean 的生命周期"></a>3).添加 Bean 后置处理器后 Bean 的生命周期</h4><blockquote>
<p>1).通过构造器或工厂方法创建 Bean 实例</p>
<p>2).为 Bean 的属性设置值和对其他 Bean 的引用</p>
<p>3).将 Bean 实例传递给 Bean后置处理器的postProcessBeforeInitialization 方法</p>
<p>4).调用 Bean 的初始化方法</p>
<p>5).将 Bean 实例传递给 Bean 后置处理器的 postProcessAfterInitialization方法</p>
<p>6).Bean 可以使用了</p>
<p>7).当容器关闭时, 调用 Bean 的销毁方法</p>
</blockquote>
<h2 id="x3D-x3D-2-4、Spring-IOC-配置类-注解版-x3D-x3D"><a href="#x3D-x3D-2-4、Spring-IOC-配置类-注解版-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;2.4、Spring IOC 配置类+注解版&#x3D;&#x3D;"></a>&#x3D;&#x3D;2.4、Spring IOC 配置类+注解版&#x3D;&#x3D;</h2><blockquote>
<p>&#x3D;&#x3D;基于注解配置Bean&#x3D;&#x3D;：标识使用注解将bean配置到IOC容器中</p>
</blockquote>
<blockquote>
<p>&#x3D;&#x3D;基于注解来装配Bean的属性&#x3D;&#x3D;：让bean与bean之间发生关联关系</p>
</blockquote>
<h3 id="1-新建Java-Config的配置类"><a href="#1-新建Java-Config的配置类" class="headerlink" title="1.新建Java Config的配置类"></a>1.新建Java Config的配置类</h3><p>Spring 能够从 classpath 下自动扫描, 侦测和实例化具有特定注解的组件. </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//@ComponentScan 指定扫描包</span><br><span class="hljs-meta">@ComponentScan(basePackages = &#123;&quot;com.igeek.ch09.config&quot;&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyConfig</span> &#123;<br><br>    <span class="hljs-comment">//@Bean </span><br><br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="2-特定组件"><a href="#2-特定组件" class="headerlink" title="2.特定组件"></a>2.特定组件</h3><h4 id="2-1-基于注解配置Bean"><a href="#2-1-基于注解配置Bean" class="headerlink" title="2.1 基于注解配置Bean"></a>2.1 基于注解配置Bean</h4><blockquote>
<p>基于注解配置Bean</p>
</blockquote>
<p>@Component: 基本注解, 标识了一个受 Spring 管理的组件</p>
<p>@Repository: 标识持久层dao层组件</p>
<p>@Service: 标识服务层(业务层)组件</p>
<p>@Controller: 标识表现层组件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//@Component注解，基础注解，一旦标注此类，代表这个类，将交由spring的IOC容器管理</span><br><span class="hljs-comment">//注解，若不指定value值，则有默认的命名策略，类名首字母小写作为它的beanName</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>&#125;<br><br><span class="hljs-comment">//@Repository 标注当前类是数据交互层的类</span><br><span class="hljs-comment">//注解，若不指定value值，则有默认的命名策略，类名首字母小写作为它的beanName</span><br><span class="hljs-meta">@Repository</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserDao</span> &#123;<br>&#125;<br><br><span class="hljs-comment">//@Service 标注是一个业务逻辑层的类</span><br><span class="hljs-comment">//注解，若不指定value值，则有默认的命名策略，类名首字母小写作为它的beanName</span><br><span class="hljs-meta">@Service(value = &quot;userServiceImpl&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span>&#123;<br>&#125;<br><br><span class="hljs-comment">//@Controller 标注当前这个类是一个控制层的类</span><br><span class="hljs-comment">//注解，若不指定value值，则有默认的命名策略，类名首字母小写作为它的beanName</span><br><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span> &#123;<br>&#125;<br><br></code></pre></td></tr></table></figure>



<h4 id="2-2-基于注解来装配Bean的属性"><a href="#2-2-基于注解来装配Bean的属性" class="headerlink" title="2.2 基于注解来装配Bean的属性"></a>2.2 基于注解来装配Bean的属性</h4><blockquote>
<p>基于注解来装配Bean的属性</p>
</blockquote>
<p>@Value(“”):给属性赋值，注入简单类型的属性   @Value(value&#x3D;”abc”)private String name;</p>
<p>@Autowired：实现自动装配</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-comment">//@Value注解，相当于在xml中给属性注入值时的value属性；给简单类型的数据赋值</span><br>    <span class="hljs-meta">@Value(value = &quot;李四&quot;)</span><br>    <span class="hljs-keyword">private</span> String username;<br>    <span class="hljs-meta">@Value(&quot;22&quot;)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br>&#125;<br><br><br><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span> &#123;<br>    <span class="hljs-comment">//@Autowired  根据属性类型进行自动装配，直接在IOC容器中找到与之类型匹配的bean实例</span><br>    <span class="hljs-meta">@Autowired(required = false)</span><br>    <span class="hljs-keyword">private</span> UserService service;<br>&#125;<br><br></code></pre></td></tr></table></figure>



<h3 id="3-对于扫描到的组件-Spring-有默认的命名策略"><a href="#3-对于扫描到的组件-Spring-有默认的命名策略" class="headerlink" title="3.对于扫描到的组件, Spring 有默认的命名策略"></a>3.对于扫描到的组件, Spring 有默认的命名策略</h3><p>使用非限定类名, 第一个字母小写；也可以使用在注解中通过 value 属性值标识组件的名称。</p>
<p>value是默认的属性，所以可以将value省略不写；可以使用value属性值来标识bean在IOC容器中的id。 </p>
<blockquote>
<p>在调用AnnotationConfigApplicationContext的构造方法时：</p>
<ol>
<li>解析MyConfig.class，得到扫描路径</li>
<li>遍历扫描路径下的所有Java类，如果发现某个类上存在@Component、@Service等注解，那么Spring就把这个类记录下来，存在一个Map中，比如Map&lt;String, Class&gt;。（<strong>实际上，Spring源码中确实存在类似的这么一个Map，叫做BeanDefinitionMap</strong>）</li>
<li>Spring会根据某个规则生成当前类对应的beanName，作为key存入Map，当前类作为value</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainTest</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-comment">//创建IOC容器</span><br>        <span class="hljs-type">AnnotationConfigApplicationContext</span> <span class="hljs-variable">ac</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotationConfigApplicationContext</span>(MyConfig.class);<br><br>        <span class="hljs-comment">//获取UserController实例</span><br>        <span class="hljs-comment">//UserController userController = ac.getBean(UserController.class);</span><br>        <span class="hljs-comment">//userController.login();</span><br><br>        <span class="hljs-comment">//获取User实例</span><br>        <span class="hljs-type">User</span> <span class="hljs-variable">user1</span> <span class="hljs-operator">=</span> ac.getBean(User.class);<br>        <span class="hljs-type">User</span> <span class="hljs-variable">user2</span> <span class="hljs-operator">=</span> ac.getBean(User.class);<br>        System.out.println(user1);<br>        System.out.println(user2);<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure>



<h3 id="5-Bean的作用域"><a href="#5-Bean的作用域" class="headerlink" title="5.Bean的作用域"></a>5.Bean的作用域</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ComponentScan(basePackages = &#123;&quot;com.igeek.config.ch03&quot;&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyConfig</span> &#123;<br><br>    <span class="hljs-comment">//@Bean 注解，将当前方法的方法名作为beanName，将当前方法的返回值作为class类型</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-comment">//@Scope 注解，指定value属性，变更作用域，例如：singleton单例  prototype原型</span><br>    <span class="hljs-meta">@Scope(&quot;prototype&quot;)</span><br>    <span class="hljs-keyword">public</span> User <span class="hljs-title function_">u</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;李思思&quot;</span>,<span class="hljs-string">&quot;222&quot;</span>);<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure>



<h3 id="6-加载外部属性文件"><a href="#6-加载外部属性文件" class="headerlink" title="6.加载外部属性文件"></a>6.加载外部属性文件</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//加载外部属性文件</span><br><span class="hljs-meta">@PropertySource(&quot;db.properties&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DataSourceConfig</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@Value</span>(&quot;zs&quot;)  简单类型，直接赋字面量的值</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@Value</span>(&quot;$&#123;db.user&#125;&quot;) 通过$&#123;key&#125;，读取属性文件properties文件上的值</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> DataSource <span class="hljs-title function_">dataSource</span><span class="hljs-params">(</span><br><span class="hljs-params">            <span class="hljs-meta">@Value(&quot;$&#123;db.user&#125;&quot;)</span> String user,</span><br><span class="hljs-params">            <span class="hljs-meta">@Value(&quot;$&#123;db.password&#125;&quot;)</span> String password,</span><br><span class="hljs-params">            <span class="hljs-meta">@Value(&quot;$&#123;db.driverClass&#125;&quot;)</span> String driverClass,</span><br><span class="hljs-params">            <span class="hljs-meta">@Value(&quot;$&#123;db.url&#125;&quot;)</span> String jdbcUrl</span><br><span class="hljs-params">    )</span> <span class="hljs-keyword">throws</span> PropertyVetoException &#123;<br>        <span class="hljs-type">ComboPooledDataSource</span> <span class="hljs-variable">dataSource</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ComboPooledDataSource</span>();<br>        dataSource.setUser(user);<br>        dataSource.setPassword(password);<br>        dataSource.setDriverClass(driverClass);<br>        dataSource.setJdbcUrl(jdbcUrl);<br>        <span class="hljs-keyword">return</span> dataSource;<br>    &#125;<br><br>&#125;<br><br><br></code></pre></td></tr></table></figure>



<h3 id="7-ExcludeFilter和IncludeFilter"><a href="#7-ExcludeFilter和IncludeFilter" class="headerlink" title="7.ExcludeFilter和IncludeFilter"></a>7.ExcludeFilter和IncludeFilter</h3><p>这两个Filter是Spring扫描过程中用来过滤的。ExcludeFilter表示<strong>排除过滤器</strong>，IncludeFilter表示<strong>包含过滤器</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//例如，指定扫描com.igeek包下面的所有类，但是排除指定的类。</span><br><span class="hljs-meta">@ComponentScan(</span><br><span class="hljs-meta">    value = &quot;com.igeek&quot;,</span><br><span class="hljs-meta">	excludeFilters = &#123;</span><br><span class="hljs-meta">        @ComponentScan.Filter(</span><br><span class="hljs-meta">            type = FilterType.ASSIGNABLE_TYPE, </span><br><span class="hljs-meta">            classes = Xxx.class)</span><br><span class="hljs-meta">    &#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyConfig</span> &#123;<br>    ...<br>&#125;<br><br></code></pre></td></tr></table></figure>

<blockquote>
<p>FilterType分为：</p>
<ol>
<li>ANNOTATION：表示是否包含某个注解</li>
<li>ASSIGNABLE_TYPE：表示是否是某个类</li>
<li>ASPECTJ：表示否是符合某个Aspectj表达式</li>
<li>REGEX：表示是否符合某个正则表达式</li>
<li>CUSTOM：自定义</li>
</ol>
</blockquote>
<h3 id="8-基于注解方式实现属性注入"><a href="#8-基于注解方式实现属性注入" class="headerlink" title="8.基于注解方式实现属性注入"></a>8.基于注解方式实现属性注入</h3><h4 id="（1）-Autowired：根据属性类型进行自动装配"><a href="#（1）-Autowired：根据属性类型进行自动装配" class="headerlink" title="（1）@Autowired：根据属性类型进行自动装配"></a>（1）@Autowired：根据属性类型进行自动装配</h4><p>第一步 把 service 和 dao 对象创建，在 service 和 dao 类分别添加创建对象注解@Service和@Repository</p>
<p>第二步 在 service 注入 dao 对象，在 service 类添加 dao 类型属性，在属性上面使用注解</p>
<p><img  src="E:/ftp%E8%B5%84%E6%96%99/note/8.SSM/1.Spring/%E8%AF%BE%E4%BB%B6/image/1624207782369.png"  ><span class="image-caption">1624207782369</span></p>
<blockquote>
<p>@Autowired注解可以写在：</p>
<ol>
<li>属性上：先根据<strong>属性类型</strong>去找Bean，如果找到多个再根据<strong>属性名</strong>确定一个</li>
<li>构造方法上：先根据方法<strong>参数类型</strong>去找Bean，如果找到多个再根据<strong>参数名</strong>确定一个</li>
<li>set方法上：先根据方法<strong>参数类型</strong>去找Bean，如果找到多个再根据<strong>参数名</strong>确定一个</li>
</ol>
</blockquote>
<h4 id="（2）-Qualifier：根据名称进行注入"><a href="#（2）-Qualifier：根据名称进行注入" class="headerlink" title="（2）@Qualifier：根据名称进行注入"></a>（2）@Qualifier：根据名称进行注入</h4><p>这个@Qualifier 注解的使用，和上面@Autowired 一起使用 </p>
<p><img  src="E:/ftp%E8%B5%84%E6%96%99/note/8.SSM/1.Spring/%E8%AF%BE%E4%BB%B6/image/1624207914606.png"  ><span class="image-caption">1624207914606</span></p>
<h4 id="（3）-Resource：可以根据类型注入，可以根据名称注入"><a href="#（3）-Resource：可以根据类型注入，可以根据名称注入" class="headerlink" title="（3）@Resource：可以根据类型注入，可以根据名称注入"></a>（3）@Resource：可以根据类型注入，可以根据名称注入</h4><p><img  src="E:/ftp%E8%B5%84%E6%96%99/note/8.SSM/1.Spring/%E8%AF%BE%E4%BB%B6/image/1624207952567.png"  ><span class="image-caption">1624207952567</span></p>
<h3 id="9-BeanPostProcessor"><a href="#9-BeanPostProcessor" class="headerlink" title="9.BeanPostProcessor"></a>9.BeanPostProcessor</h3><p>BeanPostProcessor表示Bean的后置处理器，我们可以定义一个或多个BeanPostProcessor。</p>
<p>一个BeanPostProcessor可以在<strong>任意一个Bean</strong>的<strong>初始化之前</strong>以及<strong>初始化之后</strong>去额外的做一些用户自定义的逻辑，当然，我们可以通过判断beanName来进行针对性处理（针对某个Bean，或某部分Bean）。</p>
<p>我们可以通过定义BeanPostProcessor来干涉Spring创建Bean的过程。</p>
<h4 id="9-1-创建-Bean-后置处理器"><a href="#9-1-创建-Bean-后置处理器" class="headerlink" title="9.1 创建 Bean 后置处理器"></a>9.1 创建 Bean 后置处理器</h4><blockquote>
<p>1.Bean 后置处理器允许在调用初始化方法前后对 Bean 进行额外的处理.</p>
<p>2.Bean 后置处理器对 IOC 容器里的所有 Bean 实例逐一处理, 而非单一实例. 其典型应用是: 检查 Bean 属性的正确性或根据特定的标准更改 Bean 的属性.</p>
<p>3.对Bean 后置处理器而言, 需要实现**&#x3D;&#x3D;BeanPostProcessor接口&#x3D;&#x3D;**. 在初始化方法被调用前后, Spring 将把每个 Bean 实例分别传递给上述接口的以下两个方法:</p>
</blockquote>
<p><img  src="E:/ftp%E8%B5%84%E6%96%99/note/8.SSM/1.Spring/%E8%AF%BE%E4%BB%B6/image/1624207251843.png"  ><span class="image-caption">1624207251843</span></p>
<h4 id="9-2-初始化和销毁"><a href="#9-2-初始化和销毁" class="headerlink" title="9.2 初始化和销毁"></a>9.2 初始化和销毁</h4><h5 id="1-Bean指定init-method-和-destroy-method-属性"><a href="#1-Bean指定init-method-和-destroy-method-属性" class="headerlink" title="1).Bean指定init-method 和 destroy-method 属性"></a>1).Bean指定init-method 和 destroy-method 属性</h5><p>在 Bean 的声明里设置 init-method 和 destroy-method 属性, 为 Bean 指定初始化和销毁方法.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean(name = &quot;t&quot; , initMethod = &quot;init&quot; ,destroyMethod = &quot;destroy&quot;)</span><br><span class="hljs-keyword">public</span> Tiger <span class="hljs-title function_">tiger</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Tiger</span>(<span class="hljs-string">&quot;白虎&quot;</span>,<span class="hljs-string">&quot;雌&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Tiger</span> &#123;<br><br>    <span class="hljs-meta">@Value(&quot;东北虎&quot;)</span><br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-meta">@Value(&quot;雄&quot;)</span><br>    <span class="hljs-keyword">private</span> String sex;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Tiger</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Tiger()&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Tiger</span><span class="hljs-params">(String name, String sex)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.sex = sex;<br>        System.out.println(<span class="hljs-string">&quot;Tiger(String,String)&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getSex</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> sex;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setSex</span><span class="hljs-params">(String sex)</span> &#123;<br>        <span class="hljs-built_in">this</span>.sex = sex;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Tiger&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, sex=&#x27;&quot;</span> + sex + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, dog=&quot;</span> + dog +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">destroy</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot;Tiger 销毁 destroy()&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Tiger 初始化 init()&quot;</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>



<h5 id="2-Bean实现implements-InitializingBean-DisposableBean接口"><a href="#2-Bean实现implements-InitializingBean-DisposableBean接口" class="headerlink" title="2).Bean实现implements InitializingBean , DisposableBean接口"></a>2).Bean实现implements InitializingBean , DisposableBean接口</h5><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Tiger</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InitializingBean</span> , DisposableBean &#123;<br><br>    <span class="hljs-meta">@Value(&quot;东北虎&quot;)</span><br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-meta">@Value(&quot;雄&quot;)</span><br>    <span class="hljs-keyword">private</span> String sex;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Tiger</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Tiger()&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Tiger</span><span class="hljs-params">(String name, String sex)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.sex = sex;<br>        System.out.println(<span class="hljs-string">&quot;Tiger(String,String)&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getSex</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> sex;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setSex</span><span class="hljs-params">(String sex)</span> &#123;<br>        <span class="hljs-built_in">this</span>.sex = sex;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Tiger&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, sex=&#x27;&quot;</span> + sex + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, dog=&quot;</span> + dog +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//销毁方法   DisposableBean</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">destroy</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot;Tiger 销毁 destroy()&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//初始化方法  InitializingBean</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterPropertiesSet</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot;Tiger 初始化 afterPropertiesSet()&quot;</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>



<h5 id="3-Bean方法上指定注解-PostConstruct、-PreDestroy"><a href="#3-Bean方法上指定注解-PostConstruct、-PreDestroy" class="headerlink" title="3).Bean方法上指定注解@PostConstruct、@PreDestroy"></a>3).Bean方法上指定注解@PostConstruct、@PreDestroy</h5><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Tiger</span> &#123;<br><br>    <span class="hljs-meta">@Value(&quot;东北虎&quot;)</span><br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-meta">@Value(&quot;雄&quot;)</span><br>    <span class="hljs-keyword">private</span> String sex;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Tiger</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Tiger()&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Tiger</span><span class="hljs-params">(String name, String sex)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.sex = sex;<br>        System.out.println(<span class="hljs-string">&quot;Tiger(String,String)&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getSex</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> sex;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setSex</span><span class="hljs-params">(String sex)</span> &#123;<br>        <span class="hljs-built_in">this</span>.sex = sex;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Tiger&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, sex=&#x27;&quot;</span> + sex + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, dog=&quot;</span> + dog +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@PreDestroy</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">destroy</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot;Tiger 销毁 destroy()&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@PostConstruct</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Tiger 初始化 init()&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<blockquote>
<p>注意：允许以上三种情况同时出现作用</p>
<p>执行顺序：注解方式  &gt;  接口方式  &gt;  Bean指定方法</p>
</blockquote>
<h3 id="10-管理Bean的生命周期"><a href="#10-管理Bean的生命周期" class="headerlink" title="10.管理Bean的生命周期"></a>10.管理Bean的生命周期</h3><blockquote>
<p>1.BeanDefinition 生成</p>
<p>2.实例化前</p>
<p>3.推断构造方法</p>
<p>4.实例化</p>
<p>5.实例化后 </p>
<p>6.填充属性</p>
<p>7.初始化前</p>
<p>8.初始化</p>
<p>9.初始化后</p>
<p>10.销毁</p>
</blockquote>
<h1 id="三-Spring的AOP"><a href="#三-Spring的AOP" class="headerlink" title="三.Spring的AOP"></a>三.Spring的AOP</h1><h2 id="x3D-x3D-3-1、AOP-原理-x3D-x3D"><a href="#x3D-x3D-3-1、AOP-原理-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;3.1、AOP 原理&#x3D;&#x3D;"></a>&#x3D;&#x3D;3.1、AOP 原理&#x3D;&#x3D;</h2><h3 id="1-需求"><a href="#1-需求" class="headerlink" title="1.需求"></a>1.需求</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ArithmeticCalculator</span>&#123;<br>    <span class="hljs-type">double</span> <span class="hljs-title function_">add</span> <span class="hljs-params">(<span class="hljs-type">double</span> a, <span class="hljs-type">double</span> b)</span>;<br>    <span class="hljs-type">double</span> <span class="hljs-title function_">sub</span> <span class="hljs-params">(<span class="hljs-type">double</span> a, <span class="hljs-type">double</span> b)</span>;<br>    <span class="hljs-type">double</span> <span class="hljs-title function_">mul</span> <span class="hljs-params">(<span class="hljs-type">double</span> a, <span class="hljs-type">double</span> b)</span>;<br>    <span class="hljs-type">double</span> <span class="hljs-title function_">div</span> <span class="hljs-params">(<span class="hljs-type">double</span> a, <span class="hljs-type">double</span> b)</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArithmeticCalculatorImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ArithmeticCalculator</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">add</span> <span class="hljs-params">(<span class="hljs-type">double</span> a, <span class="hljs-type">double</span> b)</span>&#123;<br>        <span class="hljs-keyword">return</span> a+b;<br>    &#125;<br>     <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">sub</span> <span class="hljs-params">(<span class="hljs-type">double</span> a, <span class="hljs-type">double</span> b)</span>&#123;<br>        <span class="hljs-keyword">return</span> a-b;<br>    &#125;<br>     <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">mul</span> <span class="hljs-params">(<span class="hljs-type">double</span> a, <span class="hljs-type">double</span> b)</span>&#123;<br>        <span class="hljs-keyword">return</span> a*b;<br>    &#125;<br>     <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">div</span> <span class="hljs-params">(<span class="hljs-type">double</span> a, <span class="hljs-type">double</span> b)</span>&#123;<br>        <span class="hljs-keyword">return</span> a/b;<br>    &#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure>

<p><strong>增加需求：</strong></p>
<p>需求1-日志：在程序执行期间追踪正在发生的活动</p>
<p>需求2-验证：希望计算器只能处理正数的运算</p>
<h3 id="2-代码实现片段"><a href="#2-代码实现片段" class="headerlink" title="2.代码实现片段"></a>2.代码实现片段</h3><p>ICount 计算器接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.cm.ch05.aop;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ICount</span> &#123;<br>	<br>	<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span>;<br>	<br>	<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sub</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span>;<br>	<br>	<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">mul</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span>;<br>	<br>	<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">div</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span>;<br>&#125;<br><br><br></code></pre></td></tr></table></figure>



<p>CountImpl 计算器实现类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.cm.ch05.aop;<br><br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CountImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ICount</span>&#123;<br><br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span>&#123;<br>		System.out.println(<span class="hljs-string">&quot;add()&quot;</span>);<br>		<span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> i+j;<br>		<span class="hljs-keyword">return</span> result;<br>	&#125;<br><br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sub</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>		System.out.println(<span class="hljs-string">&quot;sub()&quot;</span>);<br>		<span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> i-j;<br>		<span class="hljs-keyword">return</span> result;<br>	&#125;<br><br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">mul</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>		System.out.println(<span class="hljs-string">&quot;mul()&quot;</span>);<br>		<span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> i*j;<br>		<span class="hljs-keyword">return</span> result;<br>	&#125;<br><br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">div</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>		System.out.println(<span class="hljs-string">&quot;div()&quot;</span>);<br>		<span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> i/j;<br>		<span class="hljs-keyword">return</span> result;<br>	&#125;<br><br>&#125; <br><br></code></pre></td></tr></table></figure>

<p>CountLogImpl 计算器日志实现类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.cm.ch05.aop;<br><br><span class="hljs-comment">//添加需求：日志跟踪</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CountLogImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ICount</span>&#123;<br><br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>		System.out.println(<span class="hljs-string">&quot;日志追踪：the method add begin with [ &quot;</span>+i+<span class="hljs-string">&quot;,&quot;</span>+j+<span class="hljs-string">&quot; ]&quot;</span>);<br>		<span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> i+j;<br>		System.out.println(<span class="hljs-string">&quot;日志追踪：the method add end with &quot;</span>+result);<br>		<span class="hljs-keyword">return</span> result;<br>	&#125;<br><br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sub</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>		System.out.println(<span class="hljs-string">&quot;日志追踪：the method sub begin with [ &quot;</span>+i+<span class="hljs-string">&quot;,&quot;</span>+j+<span class="hljs-string">&quot; ]&quot;</span>);<br>		<span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> i-j;<br>		System.out.println(<span class="hljs-string">&quot;日志追踪：the method sub end with &quot;</span>+result);<br>		<span class="hljs-keyword">return</span> result;<br>	&#125;<br><br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">mul</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>		System.out.println(<span class="hljs-string">&quot;日志追踪：the method mul begin with [ &quot;</span>+i+<span class="hljs-string">&quot;,&quot;</span>+j+<span class="hljs-string">&quot; ]&quot;</span>);<br>		<span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> i*j;<br>		System.out.println(<span class="hljs-string">&quot;日志追踪：the method mul end with &quot;</span>+result);<br>		<span class="hljs-keyword">return</span> result;<br>	&#125;<br><br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">div</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>		System.out.println(<span class="hljs-string">&quot;日志追踪：the method div begin with [ &quot;</span>+i+<span class="hljs-string">&quot;,&quot;</span>+j+<span class="hljs-string">&quot; ]&quot;</span>);<br>		<span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> i/j;<br>		System.out.println(<span class="hljs-string">&quot;日志追踪：the method div end with &quot;</span>+result);<br>		<span class="hljs-keyword">return</span> result;<br>	&#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure>



<p><strong>问题：</strong></p>
<p><strong>1.代码混乱</strong>：越来越多的非业务需求(日志和验证等)加入后, 原有的业务方法急剧膨胀.  每个方法在处理核心逻辑的同时还必须兼顾其他多个关注点. </p>
<p><strong>2.代码分散</strong>: 以日志需求为例, 只是为了满足这个单一需求, 就不得不在多个模块（方法）里多次重复相同的日志代码. 如果日志需求发生变化, 必须修改所有模块.</p>
<h3 id="3-使用动态代理解决上述问题"><a href="#3-使用动态代理解决上述问题" class="headerlink" title="3.使用动态代理解决上述问题"></a>3.使用动态代理解决上述问题</h3><p>代理设计模式的原理: 使用一个代理将对象包装起来, 然后用该代理对象取代原始对象. 任何对原始对象的调用都要通过代理. 代理对象决定是否以及何时将方法调用转到原始对象上.</p>
<p><strong>ArithmeticCalculatorLogProxy动态代理类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArithmeticCalculatorLogProxy</span> &#123;   <span class="hljs-comment">// ArithmeticCalculatorLogProxy动态代理类</span><br>    <span class="hljs-comment">//要代理的对象</span><br>    <span class="hljs-keyword">private</span> ArithmeticCalculator target;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ArithmeticCalculatorLogProxy</span><span class="hljs-params">(ArithmeticCalculator target)</span>&#123;<br>        <span class="hljs-built_in">this</span>.target = target;<br>    &#125;<br>    <span class="hljs-keyword">public</span> ArithmeticCalculator <span class="hljs-title function_">getLogProxy</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">ArithmeticCalculator</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-comment">//代理对象由哪一个类加载器负责加载</span><br>        <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">loader</span> <span class="hljs-operator">=</span> target.getClass().getClassLoader();<br>        <span class="hljs-comment">//代理对象的类型</span><br>        Class[] interfaces = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;ArithmeticCalculator.class&#125;;<br>        <span class="hljs-comment">//当调用代理对象其中的方法时，该执行的代码</span><br>        <span class="hljs-type">InvocationHandler</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvocationHandler</span>() &#123;<br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">            * proxy:正在返回的那个代理对象。一般情况下在invoke方法中不使用该对象</span><br><span class="hljs-comment">            * method:正在被调用的方法</span><br><span class="hljs-comment">            * args:调用方法时，传入的参数</span><br><span class="hljs-comment">            */</span><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>                <span class="hljs-type">String</span> <span class="hljs-variable">methodName</span> <span class="hljs-operator">=</span> method.getName();<br>                <span class="hljs-comment">//日志</span><br>                System.out.println(<span class="hljs-string">&quot;the method &quot;</span>+methodName+<span class="hljs-string">&quot; begin with &quot;</span>+Arrays.asList(args));<br>                <span class="hljs-comment">//执行方法</span><br>                <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> method.invoke(target, args);<br>                <span class="hljs-comment">//日志</span><br>                System.out.println(<span class="hljs-string">&quot;the method &quot;</span>+methodName+<span class="hljs-string">&quot; end with &quot;</span>+result);<br>                <span class="hljs-keyword">return</span> result;<br>            &#125;<br>        &#125;;<br>        proxy = (ArithmeticCalculator)Proxy.newProxyInstance(loader, interfaces, h);<br>        <span class="hljs-keyword">return</span> proxy;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p><strong>测试</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">ArithmeticCalculator</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArithmeticCalculatorImpl</span>();<br><span class="hljs-type">ArithmeticCalculator</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArithmeticCalculatorLogProxy</span>(target).getLogProxy();<br>		<br><span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> proxy.add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>System.out.println(<span class="hljs-string">&quot;--&gt;&quot;</span>+result);<br><br>result = proxy.div(<span class="hljs-number">4</span>, <span class="hljs-number">2</span>);<br>System.out.println(<span class="hljs-string">&quot;--&gt;&quot;</span>+result);<br></code></pre></td></tr></table></figure>



<h2 id="3-2、AOP-简介"><a href="#3-2、AOP-简介" class="headerlink" title="3.2、AOP 简介"></a>3.2、AOP 简介</h2><h3 id="x3D-x3D-1-AOP-Aspect-Oriented-Programming-面向切面编程-x3D-x3D"><a href="#x3D-x3D-1-AOP-Aspect-Oriented-Programming-面向切面编程-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;1.AOP(Aspect-Oriented Programming, 面向切面编程)&#x3D;&#x3D;"></a>&#x3D;&#x3D;1.AOP(Aspect-Oriented Programming, 面向切面编程)&#x3D;&#x3D;</h3><blockquote>
<p>是一种新的方法论, 是对传统 OOP(Object-Oriented Programming, 面向对象编程) 的补充.</p>
<p>AOP 的主要编程对象是&#x3D;&#x3D;切面(aspect)&#x3D;&#x3D;, 而切面&#x3D;&#x3D;模块化横切关注点&#x3D;&#x3D;.</p>
<p>在应用 AOP 编程时，仍然需要定义公共功能, 但可以明确的定义这个功能在哪里, 以什么方式应用, 并且不必修改受影响的类. 这样一来横切关注点就被模块化到特殊的对象(切面)里.</p>
</blockquote>
<h3 id="2-AOP的好处"><a href="#2-AOP的好处" class="headerlink" title="2.AOP的好处"></a>2.AOP的好处</h3><p>1). 每个事物逻辑位于一个位置, 代码不分散, 便于维护和升级</p>
<p>2). 业务模块更简洁, 只包含核心业务代码. </p>
<h3 id="3-AOP术语"><a href="#3-AOP术语" class="headerlink" title="3.AOP术语"></a>3.AOP术语</h3><p>1). &#x3D;&#x3D;切面(Aspect)&#x3D;&#x3D;:  横切关注点(跨越应用程序多个模块的功能)被模块化的类</p>
<p>2). &#x3D;&#x3D;通知(Advice)&#x3D;&#x3D;:  切面必须要完成的工作(切面中的每一个方法被称为通知)</p>
<p>3). 目标(Target): 被通知的对象</p>
<p>4). 代理(Proxy): 向目标对象应用通知之后创建的对象</p>
<p>5). &#x3D;&#x3D;连接点（Joinpoint）&#x3D;&#x3D;：程序执行的某个特定位置（一个具体的物理存在）：如类某个方法调用前、调用后、方法抛出异常后等。连接点由两个信息确定：方法表示的程序执行点；相对点表示的方位。例如 ArithmethicCalculator#add() 方法执行前的连接点，执行点为 ArithmethicCalculator#add()； 方位为该方法执行前的位置</p>
<p>6). &#x3D;&#x3D;切点（pointcut）&#x3D;&#x3D;：每个类都拥有多个连接点：例如 ArithmethicCalculator 的所有方法实际上都是连接点，即连接点是程序类中客观存在的事务。AOP 通过切点定位到特定的连接点。类比：连接点相当于数据库中的记录，切点相当于查询条件。切点和连接点不是一对一的关系，一个切点匹配多个连接点，切点通过 org.springframework.aop.Pointcut 接口进行描述，它使用类和方法作为连接点的查询条件。</p>
<h2 id="x3D-x3D-3-3、Spring-AOP-注解-配置类版-x3D-x3D"><a href="#x3D-x3D-3-3、Spring-AOP-注解-配置类版-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;3.3、Spring  AOP  注解+ 配置类版&#x3D;&#x3D;"></a>&#x3D;&#x3D;3.3、Spring  AOP  注解+ 配置类版&#x3D;&#x3D;</h2><p>1).AspectJ：Java 社区里最完整最流行的 AOP 框架.</p>
<p>2).在 Spring2.0 以上版本中, 可以使用基于 AspectJ 注解或基于 XML 配置的 AOP</p>
<h3 id="1-修改pom-xml"><a href="#1-修改pom-xml" class="headerlink" title="1.修改pom.xml"></a>1.修改pom.xml</h3><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-aop --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-aop<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.3.13<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 引入aspectj依赖 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.aspectj<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>aspectjweaver<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.9.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br></code></pre></td></tr></table></figure>



<h3 id="2-新建spring的核心配置类"><a href="#2-新建spring的核心配置类" class="headerlink" title="2.新建spring的核心配置类"></a>2.新建spring的核心配置类</h3><p>要在 Spring IOC 容器中启用 AspectJ 注解支持</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//开启Aspect面向切面编程   proxyTargetClass = true开启CGLIB动态代理</span><br><span class="hljs-meta">@EnableAspectJAutoProxy(proxyTargetClass = true)</span><br><span class="hljs-comment">//配置扫描包</span><br><span class="hljs-meta">@ComponentScan(&quot;com.igeek.aop.ch03.config&quot;)</span><br><span class="hljs-comment">//当前类是一个配置类</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyConfig</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@Bean</span> 注解</span><br><span class="hljs-comment">     * 1.将当前方法的返回值放入IOC容器进行管理</span><br><span class="hljs-comment">     * 2.无论getBean多少次，获得都是唯一的实例，因为Spring IOC容器，默认单实例</span><br><span class="hljs-comment">     * 3.当前实例放入IOC容器后，会将当前方法名作为BeanName来进行使用</span><br><span class="hljs-comment">     * 4.<span class="hljs-doctag">@Bean</span>在配置类，搭配创建组件</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-comment">//@Scope(&quot;prototype&quot;)</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> ArithmeticCalculator <span class="hljs-title function_">c</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArithmeticCalculator</span>();<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure>



<h3 id="3-用-AspectJ-注解声明切面"><a href="#3-用-AspectJ-注解声明切面" class="headerlink" title="3.用 AspectJ 注解声明切面"></a>3.用 AspectJ 注解声明切面</h3><p>1).要在 Spring 中声明 AspectJ 切面, 只需要<strong>在 IOC 容器中</strong>将切面声明为 Bean 实例. 当在 Spring IOC 容器中初始化 AspectJ 切面之后, Spring IOC 容器就会为那些与 AspectJ 切面相匹配的 Bean 创建代理.</p>
<p>2).在 AspectJ 注解中, 切面只是一个<strong>带有 @Aspect 注解</strong>的 Java 类. </p>
<p>3).通知是标注有某种注解的简单的 Java 方法.</p>
<p>4).AspectJ 支持 5 种类型的通知注解: </p>
<blockquote>
<p>@Before: 前置通知, 在方法执行之前执行</p>
<p>@After: 后置通知, 在方法执行之后执行 </p>
<p>@AfterReturning: 返回通知, 在方法返回结果之后执行</p>
<p>@AfterThrowing: 异常通知, 在方法抛出异常之后</p>
<p>@Around: 环绕通知, 围绕着方法执行</p>
</blockquote>
<h3 id="4-通知"><a href="#4-通知" class="headerlink" title="4.通知"></a>4.通知</h3><h4 id="1-前置通知"><a href="#1-前置通知" class="headerlink" title="1).前置通知"></a>1).前置通知</h4><p>在方法执行之前执行的通知，前置通知使用 <strong>@Before 注解</strong>, 并将切入点表达式的值作为注解值.</p>
<h4 id="2-后置通知"><a href="#2-后置通知" class="headerlink" title="2).后置通知"></a>2).后置通知</h4><p><strong>@After</strong>是在连接点完成之后执行的, 即连接点返回结果或者抛出异常的时候, 下面的后置通知记录了方法的终止. </p>
<h4 id="3-返回通知"><a href="#3-返回通知" class="headerlink" title="3).返回通知"></a>3).返回通知</h4><blockquote>
<p>无论连接点是正常返回还是抛出异常, 后置通知都会执行. 如果只想在连接点返回的时候记录日志, 应使用返回通知代替后置通知.</p>
<p>在返回通知中访问连接点的返回值</p>
<p>1).在返回通知中, 只要将 returning 属性添加到 <strong>@AfterReturning 注解</strong>中, 就可以访问连接点的返回值. 该属性的值即为用来传入返回值的参数名称. </p>
<p>2).必须在通知方法的签名中添加一个同名参数. 在运行时, Spring AOP 会通过这个参数传递返回值.</p>
<p>3).原始的切点表达式需要出现在 pointcut 属性中</p>
</blockquote>
<h4 id="4-异常通知"><a href="#4-异常通知" class="headerlink" title="4).异常通知"></a>4).异常通知</h4><p>1).只在连接点抛出异常时才执行异常通知</p>
<p>2).将 throwing 属性添加到 <strong>@AfterThrowing 注解</strong>中, 也可以访问连接点抛出的异常. Throwable 是所有错误和异常类的超类. 所以在异常通知方法可以捕获到任何错误和异常.</p>
<p>3).如果只对某种特殊的异常类型感兴趣, 可以将参数声明为其他异常的参数类型. 然后通知就只在抛出这个类型及其子类的异常时才被执行.</p>
<h4 id="5-环绕通知"><a href="#5-环绕通知" class="headerlink" title="5).环绕通知"></a>5).环绕通知</h4><p>1). 环绕通知**@Around**是所有通知类型中功能最为强大的, 能够全面地控制连接点. 甚至可以控制是否执行连接点. </p>
<p>2).对于环绕通知来说, 连接点的参数类型必须是 <strong>ProceedingJoinPoint</strong> . 它是 JoinPoint 的子接口, 允许控制何时执行, 是否执行连接点.</p>
<p>3).在环绕通知中需要明确调用 <strong>ProceedingJoinPoint 的 proceed() 方法</strong>来执行被代理的方法. 如果忘记这样做就会导致通知被执行了, 但目标方法没有被执行.</p>
<p>4).注意: 环绕通知的方法需要返回目标方法执行之后的结果, 即调用 joinPoint.proceed(); 的返回值, 否则会出现空指针异常</p>
<h3 id="5-利用方法签名编写-AspectJ-切入点表达式"><a href="#5-利用方法签名编写-AspectJ-切入点表达式" class="headerlink" title="5.利用方法签名编写 AspectJ 切入点表达式"></a>5.利用方法签名编写 AspectJ 切入点表达式</h3><p>1).<strong>execution * com.igeek.spring.ArithmeticCalculator.*(..)</strong>: 匹配 ArithmeticCalculator 中声明的所有方法,第一个 * 代表任意修饰符及任意返回值. 第二个 * 代表任意方法. .. 匹配任意数量的参数. 若目标类与接口与该切面在同一个包中, 可以省略包名.</p>
<p>2).execution public * ArithmeticCalculator.*(..): 匹配 ArithmeticCalculator 接口的所有公有方法.</p>
<p>3).execution public double ArithmeticCalculator.*(..): 匹配 ArithmeticCalculator 中返回 double 类型数值的方法</p>
<p>4).execution public double ArithmeticCalculator.*(double, ..): 匹配第一个参数为 double 类型的方法, .. 匹配任意数量任意类型的参数</p>
<p>5).execution public double ArithmeticCalculator.*(double, double): 匹配参数类型为 double, double 类型的方法.</p>
<h3 id="6-指定切面的优先级"><a href="#6-指定切面的优先级" class="headerlink" title="6.指定切面的优先级"></a>6.指定切面的优先级</h3><p>1).在同一个连接点上应用不止一个切面时, 除非明确指定, 否则它们的优先级是不确定的.</p>
<p>2).切面的优先级可以通过实现 Ordered 接口或利用 @Order 注解指定.</p>
<p>3).实现 Ordered 接口, getOrder() 方法的返回<strong>值越小, 优先级越高.</strong></p>
<p>4).若使用 <strong>@Order 注解</strong>, 序号出现在注解</p>
<h3 id="7-重用切入点定义"><a href="#7-重用切入点定义" class="headerlink" title="7.重用切入点定义"></a>7.重用切入点定义</h3><p>1).在编写 AspectJ 切面时, 可以直接在通知注解中书写切入点表达式. 但同一个切点表达式可能会在多个通知中重复出现.</p>
<p>2).在 AspectJ 切面中, 可以通过 <strong>@Pointcut 注解</strong>将一个切入点声明成简单的方法. 切入点的方法体通常是空的, 因为将切入点定义与应用程序逻辑混在一起是不合理的. </p>
<p>3).切入点方法的访问控制符同时也控制着这个切入点的可见性。如果切入点要在多个切面中共用, 最好将它们集中在一个公共的类中. 在这种情况下, 它们必须被声明为 public. 在引入这个切入点时, 必须将类名也包括在内. 如果类没有与这个切面放在同一个包中, 还必须包含包名.</p>
<p>4).其他通知可以通过方法名称引入该切入点.</p>
<h3 id="8-案例"><a href="#8-案例" class="headerlink" title="8.案例"></a>8.案例</h3><p>一个切面可以包括一个或者多个通知.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.cm.ch05.aop;<br><br><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">import</span> org.aspectj.lang.JoinPoint;<br><span class="hljs-keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;<br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.After;<br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.AfterReturning;<br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.AfterThrowing;<br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.Around;<br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.Aspect;<br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.Before;<br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.Pointcut;<br><span class="hljs-keyword">import</span> org.springframework.core.annotation.Order;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 日志切面</span><br><span class="hljs-comment"> * 切面:横切关注点</span><br><span class="hljs-comment"> * 1.将当前类添加到IOC容器中：@Component</span><br><span class="hljs-comment"> * 2.将当前类可以进行使用AOP：@Aspect</span><br><span class="hljs-comment"> * 3.@Order(2)  切面的优先级，数值越小越先执行</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Order(2)</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Aspect</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LogAspect</span> &#123;<br><br>	<span class="hljs-comment">//公共切入点:通过 @Pointcut 注解将一个切入点声明成简单的方法. 切入点的方法体通常是空的</span><br>	<span class="hljs-meta">@Pointcut(&quot;execution(public int com.cm.ch05.aop.CountImpl.*(int,int))&quot;)</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">declarePointcut</span><span class="hljs-params">()</span>&#123;&#125;<br><br><br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * 前置通知:@Before(&quot;execution(public int com.cm.ch05.aop.CountImpl.*(int,int))&quot;)</span><br><span class="hljs-comment">	 * 1.@Before</span><br><span class="hljs-comment">	 * 2.切点pointcut：(&quot;execution(xxx)&quot;)</span><br><span class="hljs-comment">	 * 3.简化的语法：@Before(&quot;execution(* CountImpl.*(..))&quot;)</span><br><span class="hljs-comment">	 * 第一个*：任意访问权限和任意返回值</span><br><span class="hljs-comment">	 * 第二个*：指定类下的任意方法</span><br><span class="hljs-comment">	 * 第三个..：匹配任意参数</span><br><span class="hljs-comment">	 * PS:同包下，包名可省略</span><br><span class="hljs-comment">	 * 4.JoinPoint 连接点：获得当前正在访问的方法名，参数列表</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-comment">//@Before(&quot;execution(* CountImpl.*(..))&quot;)</span><br>	<span class="hljs-meta">@Before(&quot;declarePointcut()&quot;)</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">beforeAdvice</span><span class="hljs-params">(JoinPoint jp)</span>&#123;<br>		<span class="hljs-comment">//方法名</span><br>		<span class="hljs-type">String</span> <span class="hljs-variable">methodName</span> <span class="hljs-operator">=</span> jp.getSignature().getName();<br>		<span class="hljs-comment">//参数列表</span><br>		List&lt;Object&gt; args = Arrays.asList(jp.getArgs());<br>		System.out.println(<span class="hljs-string">&quot;日志追踪：the method &quot;</span>+methodName+<span class="hljs-string">&quot; begin with &quot;</span>+args);<br>	&#125;<br><br>	<span class="hljs-comment">//返回通知:returning值的名字必须与方法中参数的形参名字一致</span><br>	<span class="hljs-comment">//@AfterReturning(pointcut=&quot;execution(* CountImpl.*(..))&quot;,returning=&quot;result&quot;)</span><br>	<span class="hljs-meta">@AfterReturning(pointcut=&quot;declarePointcut()&quot;,returning=&quot;result&quot;)</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">AfterReturningAdvice</span><span class="hljs-params">(JoinPoint jp,Object result)</span> <span class="hljs-keyword">throws</span> Throwable&#123;<br>		<span class="hljs-comment">//方法名</span><br>		<span class="hljs-type">String</span> <span class="hljs-variable">methodName</span> <span class="hljs-operator">=</span> jp.getSignature().getName();<br>		System.out.println(<span class="hljs-string">&quot;日志追踪：the method &quot;</span>+methodName+<span class="hljs-string">&quot; end with &quot;</span>+result);<br>	&#125;<br><br>	<span class="hljs-comment">//异常通知:throwing值的名字必须与方法中参数的形参名字一致</span><br>	<span class="hljs-comment">//@AfterThrowing(value=&quot;execution(* CountImpl.*(..))&quot;,throwing=&quot;ex&quot;)</span><br>	<span class="hljs-meta">@AfterThrowing(pointcut=&quot;declarePointcut()&quot;,throwing=&quot;ex&quot;)</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">AfterThrowingAdvice</span><span class="hljs-params">(JoinPoint jp,Exception ex)</span>&#123;<br>		<span class="hljs-comment">//方法名</span><br>		<span class="hljs-type">String</span> <span class="hljs-variable">methodName</span> <span class="hljs-operator">=</span> jp.getSignature().getName();<br>		System.out.println(<span class="hljs-string">&quot;日志追踪：the method &quot;</span>+methodName+<span class="hljs-string">&quot; occurn exception:&quot;</span>+ex);<br>	&#125;<br><br>	<span class="hljs-comment">//后置通知</span><br>	<span class="hljs-comment">//@After(&quot;execution(* CountImpl.*(..))&quot;)</span><br>	<span class="hljs-meta">@After(&quot;declarePointcut()&quot;)</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">AfterAdvice</span><span class="hljs-params">(JoinPoint jp)</span>&#123;<br>		<span class="hljs-comment">//方法名</span><br>		<span class="hljs-type">String</span> <span class="hljs-variable">methodName</span> <span class="hljs-operator">=</span> jp.getSignature().getName();<br>		System.out.println(<span class="hljs-string">&quot;日志追踪：the method &quot;</span>+methodName+<span class="hljs-string">&quot; end with&quot;</span>);<br>	&#125;<br><br>	<span class="hljs-comment">//环绕通知</span><br>	<span class="hljs-comment">//@Around(&quot;execution(* CountImpl.*(..))&quot;)</span><br>	<span class="hljs-keyword">public</span> Object <span class="hljs-title function_">AroundAdvice</span><span class="hljs-params">(ProceedingJoinPoint pjp)</span>&#123;<br>		<span class="hljs-type">String</span> <span class="hljs-variable">methodName</span> <span class="hljs-operator">=</span> pjp.getSignature().getName();<br>		List&lt;Object&gt; args = Arrays.asList(pjp.getArgs());<br>		<span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>		<span class="hljs-keyword">try</span> &#123;<br>			<span class="hljs-comment">//前置通知</span><br>			System.out.println(<span class="hljs-string">&quot;日志追踪：the method &quot;</span>+methodName+<span class="hljs-string">&quot; begin with &quot;</span>+args);<br>			result = pjp.proceed();<br>			<span class="hljs-comment">//返回通知</span><br>			System.out.println(<span class="hljs-string">&quot;日志追踪：the method &quot;</span>+methodName+<span class="hljs-string">&quot; end with &quot;</span>+result);<br>		&#125; <span class="hljs-keyword">catch</span> (Throwable e) &#123;<br>			<span class="hljs-comment">//环绕通知</span><br>			System.out.println(<span class="hljs-string">&quot;日志追踪：the method &quot;</span>+methodName+<span class="hljs-string">&quot; occurs exception:&quot;</span>+e.getMessage());<br>		&#125;<br>		<span class="hljs-comment">//后置通知</span><br>		System.out.println(<span class="hljs-string">&quot;日志追踪：the method &quot;</span>+methodName+<span class="hljs-string">&quot; end with&quot;</span>);<br>		<span class="hljs-keyword">return</span> result;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="9-测试"><a href="#9-测试" class="headerlink" title="9.测试"></a>9.测试</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//1.创建IOC容器  AnnotationConfigApplicationContext</span><br>        <span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">ac</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotationConfigApplicationContext</span>(MyConfig.class);<br><br>        <span class="hljs-comment">//2.获得实例bean</span><br>        <span class="hljs-type">ArithmeticCalculator</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> ac.getBean(ArithmeticCalculator.class);<br>        <span class="hljs-comment">//com.igeek.aop.ch03.config.ArithmeticCalculator$$EnhancerBySpringCGLIB$$b304c68a</span><br>        System.out.println(proxy.getClass().getName());<br><br>        <span class="hljs-comment">//3.使用实例bean</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">result1</span> <span class="hljs-operator">=</span> proxy.add(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>);<br>        System.out.println(<span class="hljs-string">&quot;result1 = &quot;</span>+result1);<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">result2</span> <span class="hljs-operator">=</span> proxy.div(-<span class="hljs-number">10</span>, <span class="hljs-number">5</span>);<br>        System.out.println(<span class="hljs-string">&quot;result2 = &quot;</span>+result2);<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure>



<h2 id="3-4、Spring-AOP-XML版"><a href="#3-4、Spring-AOP-XML版" class="headerlink" title="3.4、Spring  AOP  XML版"></a>3.4、Spring  AOP  XML版</h2><h3 id="1-基于-XML-—-声明切面"><a href="#1-基于-XML-—-声明切面" class="headerlink" title="1.基于 XML —- 声明切面"></a>1.基于 XML —- 声明切面</h3><blockquote>
<p>1.当使用 XML 声明切面时, 需要在 <beans> 根元素中导入 aop Schema</p>
<p>2.在 Bean 配置文件中, 所有的 Spring AOP 配置都必须定义在 <a href="aop:config">aop:config</a> 元素内部. 对于每个切面而言, 都要创建一个 <a href="aop:aspect">aop:aspect</a> 元素来为具体的切面实现引用后端 Bean 实例. </p>
<p>3.切面 Bean 必须有一个标示符, 供 <a href="aop:aspect">aop:aspect</a> 元素引用</p>
</blockquote>
<h3 id="2-基于-XML-—-声明切入点"><a href="#2-基于-XML-—-声明切入点" class="headerlink" title="2.基于 XML —- 声明切入点"></a>2.基于 XML —- 声明切入点</h3><blockquote>
<p>1.切入点使用<a href="aop:pointcut">aop:pointcut</a>元素声明</p>
<p>2.切入点必须定义在 <a href="aop:aspect">aop:aspect</a> 元素下, 或者直接定义在 <a href="aop:config">aop:config</a> 元素下.</p>
<p>1).定义在 <a href="aop:aspect">aop:aspect</a> 元素下: 只对当前切面有效</p>
<p>2).定义在 <a href="aop:config">aop:config</a> 元素下: 对所有切面都有效</p>
<p>3.基于 XML 的 AOP 配置不允许在切入点表达式中用名称引用其他切入点. </p>
</blockquote>
<h3 id="3-基于-XML-—-声明通知"><a href="#3-基于-XML-—-声明通知" class="headerlink" title="3.基于 XML —- 声明通知"></a>3.基于 XML —- 声明通知</h3><blockquote>
<p>1.在 aop Schema 中, 每种通知类型都对应一个特定的 XML 元素. </p>
<p>2.通知元素需要使用 <pointcut-ref> 来引用切入点, 或用 <pointcut> 直接嵌入切入点表达式.  method 属性指定切面类中通知方法的名称.</p>
</blockquote>
<h3 id="4-案例"><a href="#4-案例" class="headerlink" title="4.案例"></a>4.案例</h3><p><img  src="E:/ftp%E8%B5%84%E6%96%99/note/8.SSM/1.Spring/%E8%AF%BE%E4%BB%B6/image/1624209454641.png"  ><span class="image-caption">1624209454641</span></p>
<h1 id="四-Spring的事务管理"><a href="#四-Spring的事务管理" class="headerlink" title="四.Spring的事务管理"></a>四.Spring的事务管理</h1><h2 id="1-事务简介"><a href="#1-事务简介" class="headerlink" title="1.事务简介"></a>1.事务简介</h2><p>1).事务管理是企业级应用程序开发中必不可少的技术,  用来确保数据的完整性和一致性.</p>
<p>2).事务就是一系列的动作, 它们被当做一个单独的工作单元. 这些动作要么全部完成, 要么全部不起作用</p>
<p>3).事务的四个关键属性(ACID)</p>
<p><strong>原子性(atomicity)</strong>: 事务是一个原子操作, 由一系列动作组成. 事务的原子性确保动作要么全部完成要么完全不起作用.</p>
<p><strong>一致性(consistency)</strong>: 一旦所有事务动作完成, 事务就被提交. 数据和资源就处于一种满足业务规则的一致性状态中.</p>
<p><strong>隔离性(isolation)</strong>: 可能有许多事务会同时处理相同的数据, 因此每个事物都应该与其他事务隔离开来, 防止数据损坏.</p>
<p><strong>持久性(durability)</strong>: 一旦事务完成, 无论发生什么系统错误, 它的结果都不应该受到影响. 通常情况下, 事务的结果被写到持久化存储器中.</p>
<h2 id="2-Spring-中的事务管理"><a href="#2-Spring-中的事务管理" class="headerlink" title="2.Spring 中的事务管理"></a>2.Spring 中的事务管理</h2><p>1).作为企业级应用程序框架, Spring 在不同的事务管理 API 之上定义了一个抽象层. 而应用程序开发人员不必了解底层的事务管理 API, 就可以使用 Spring 的事务管理机制.</p>
<p>2).Spring 既支持编程式事务管理, 也支持声明式的事务管理. </p>
<p>3).编程式事务管理: 将事务管理代码嵌入到业务方法中来控制事务的提交和回滚. 在编程式管理事务时, <strong>必须在每个事务操作中包含额外的事务管理代码</strong>. </p>
<p>4).声明式事务管理: 大多数情况下比编程式事务管理更好用. 它将事务管理代码从业务方法中分离出来, 以声明的方式来实现事务管理. &#x3D;&#x3D;事务管理作为一种横切关注点, 可以<strong>通过 AOP 方法模块化</strong>&#x3D;&#x3D;. Spring 通过 Spring AOP 框架支持声明式事务管理.</p>
<h2 id="3-Spring-中的事务管理器"><a href="#3-Spring-中的事务管理器" class="headerlink" title="3.Spring 中的事务管理器"></a>3.Spring 中的事务管理器</h2><p>1.Spring 从不同的事务管理 API 中抽象了一整套的事务机制. 开发人员不必了解底层的事务 API, 就可以利用这些事务机制. 有了这些事务机制, 事务管理代码就能独立于特定的事务技术了.</p>
<p>2.Spring 的核心事务管理抽象类TransactionManager，它为事务管理封装了一组独立于技术的方法. 无论使用 Spring 的哪种事务管理策略(编程式或声明式), 事务管理器都是必须的.</p>
<p>3.<strong>DataSourceTransactionManager</strong>：在应用程序中只需要处理一个数据源, 而且通过 JDBC 存取。事务管理器以普通的 Bean 形式声明在 Spring IOC 容器中。</p>
<h2 id="x3D-x3D-4-Transactional-注解-配置类-声明式管理事务-x3D-x3D"><a href="#x3D-x3D-4-Transactional-注解-配置类-声明式管理事务-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;4.@Transactional 注解+配置类 声明式管理事务&#x3D;&#x3D;"></a>&#x3D;&#x3D;4.@Transactional 注解+配置类 声明式管理事务&#x3D;&#x3D;</h2><h3 id="4-1-修改pom-xml"><a href="#4-1-修改pom-xml" class="headerlink" title="4.1 修改pom.xml"></a>4.1 修改pom.xml</h3><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 引入spring的JDBC依赖 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-jdbc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.3.13<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--mysql驱动包 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.0.16<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--c3p0 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>c3p0<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>c3p0<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.9.1.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 单元测试 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.10<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br></code></pre></td></tr></table></figure>



<h3 id="4-2-新建spring的配置类"><a href="#4-2-新建spring的配置类" class="headerlink" title="4.2 新建spring的配置类"></a>4.2 新建spring的配置类</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//开启事务管理器  (proxyTargetClass = true)开启CGLIB动态代理</span><br><span class="hljs-meta">@EnableTransactionManagement(proxyTargetClass = true)</span><br><span class="hljs-comment">//添加扫描包</span><br><span class="hljs-meta">@ComponentScan(&quot;com.igeek.ch27.config&quot;)</span><br><span class="hljs-comment">//加载外部属性文件</span><br><span class="hljs-meta">@PropertySource(&quot;db.properties&quot;)</span><br><span class="hljs-comment">//配置类</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyConfig</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@Bean</span>   配置数据源</span><br><span class="hljs-comment">     * 1.将当前方法的返回值放入IOC容器中管理，默认singleton单例</span><br><span class="hljs-comment">     * 2.将当前方法的名称作为BeanName存入容器中</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> DataSource <span class="hljs-title function_">dataSource</span><span class="hljs-params">(</span><br><span class="hljs-params">            <span class="hljs-meta">@Value(&quot;$&#123;db.name&#125;&quot;)</span> String name,</span><br><span class="hljs-params">            <span class="hljs-meta">@Value(&quot;$&#123;db.password&#125;&quot;)</span> String password,</span><br><span class="hljs-params">            <span class="hljs-meta">@Value(&quot;$&#123;db.jdbcUrl&#125;&quot;)</span> String jdbcUrl,</span><br><span class="hljs-params">            <span class="hljs-meta">@Value(&quot;$&#123;db.driverClass&#125;&quot;)</span> String driverClass</span><br><span class="hljs-params">    )</span> <span class="hljs-keyword">throws</span> PropertyVetoException &#123;<br>        <span class="hljs-comment">//创建一个数据源</span><br>        <span class="hljs-type">ComboPooledDataSource</span> <span class="hljs-variable">dataSource</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ComboPooledDataSource</span>();<br>        <span class="hljs-comment">//将相关连接配置上</span><br>        dataSource.setUser(name);<br>        dataSource.setPassword(password);<br>        dataSource.setJdbcUrl(jdbcUrl);<br>        dataSource.setDriverClass(driverClass);<br>        <span class="hljs-comment">//返回数据源</span><br>        <span class="hljs-keyword">return</span> dataSource;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@Bean</span>  配置JdbcTemplate</span><br><span class="hljs-comment">     * 1.将当前方法的返回值放入IOC容器中管理，默认singleton单例</span><br><span class="hljs-comment">     * 2.将当前方法的名称作为BeanName存入容器中</span><br><span class="hljs-comment">     * 3.一旦方法中有形参，<span class="hljs-doctag">@Bean</span>会在IOC容器中查找到实例并注入进来</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> JdbcTemplate <span class="hljs-title function_">jdbcTemplate</span><span class="hljs-params">(DataSource dataSource)</span>&#123;<br>        <span class="hljs-type">JdbcTemplate</span> <span class="hljs-variable">jdbcTemplate</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JdbcTemplate</span>(dataSource);<br>        <span class="hljs-keyword">return</span> jdbcTemplate;<br>    &#125;<br><br><br>    <span class="hljs-comment">//将事务管理器实例放置IOC容器中管理</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> PlatformTransactionManager <span class="hljs-title function_">platformTransactionManager</span><span class="hljs-params">(DataSource dataSource)</span>&#123;<br>        <span class="hljs-type">DataSourceTransactionManager</span> <span class="hljs-variable">dataSourceTransactionManager</span> <span class="hljs-operator">=</span><br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataSourceTransactionManager</span>(dataSource);<br>        <span class="hljs-keyword">return</span> dataSourceTransactionManager;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>





<h3 id="4-3-用-Transactional-注解声明式管理事务"><a href="#4-3-用-Transactional-注解声明式管理事务" class="headerlink" title="4.3 用 @Transactional 注解声明式管理事务"></a>4.3 用 @Transactional 注解声明式管理事务</h3><p>1).除了在带有切入点, 通知和增强器的 Bean 配置文件中声明事务外, Spring 还允许简单地用 @Transactional 注解来标注事务方法.</p>
<p>2).为了将方法定义为支持事务处理的, 可以为方法添加 @Transactional 注解. 根据 Spring AOP 基于代理机制, 只能标注公有方法.</p>
<p>3).可以在方法或者类级别上添加 @Transactional 注解. 当把这个注解应用到类上时, 这个类中的所有公共方法都会被定义成支持事务处理的. </p>
<h4 id="1）、事务传播属性"><a href="#1）、事务传播属性" class="headerlink" title="1）、事务传播属性"></a>1）、事务传播属性</h4><blockquote>
<p>&#x3D;&#x3D;当事务方法被另一个事务方法调用时, 必须指定事务应该如何传播&#x3D;&#x3D;. 例如: 方法可能继续在现有事务中运行, 也可能开启一个新事务, 并在自己的事务中运行.</p>
<p>事务的传播行为可以由传播属性指定. </p>
</blockquote>
<p><img  src="E:/ftp%E8%B5%84%E6%96%99/note/8.SSM/1.Spring/%E8%AF%BE%E4%BB%B6/image/image-20200713030313168.png"  ><span class="image-caption">image-20200713030313168</span></p>
<blockquote>
<p>REQUIRED 传播行为</p>
<p>1).例如当购买方法purchase() 被另一个事务方法 checkout() 调用时, 它默认会在现有的事务内运行。这个默认的传播行为就是 REQUIRED. 因此在 checkout() 方法的开始和终止边界内只有一个事务. 这个事务只在 checkout() 方法结束的时候被提交。</p>
<p>2).事务传播属性可以在 @Transactional 注解的 propagation 属性中定义</p>
</blockquote>
<p><img  src="E:/ftp%E8%B5%84%E6%96%99/note/8.SSM/1.Spring/%E8%AF%BE%E4%BB%B6/image/image-20200713030508879.png"  ><span class="image-caption">image-20200713030508879</span></p>
<p><img  src="E:/ftp%E8%B5%84%E6%96%99/note/8.SSM/1.Spring/%E8%AF%BE%E4%BB%B6/image/wps4u6ax2.png"  ><span class="image-caption">img</span></p>
<blockquote>
<p>REQUIRES_NEW 传播行为</p>
<p>另一种常见的传播行为是 REQUIRES_NEW. 它表示该方法必须启动一个新事务, 并在自己的事务内运行. 如果有事务在运行, 就应该先挂起它.</p>
</blockquote>
<p><img  src="E:/ftp%E8%B5%84%E6%96%99/note/8.SSM/1.Spring/%E8%AF%BE%E4%BB%B6/image/wpsvszCQD.png"  ><span class="image-caption">img</span> </p>
<p><img  src="E:/ftp%E8%B5%84%E6%96%99/note/8.SSM/1.Spring/%E8%AF%BE%E4%BB%B6/image/wpsIxaTZU.png"  ><span class="image-caption">img</span></p>
<h4 id="2）、事务的隔离级别"><a href="#2）、事务的隔离级别" class="headerlink" title="2）、事务的隔离级别"></a>2）、事务的隔离级别</h4><blockquote>
<p>并发事务所导致的问题</p>
<p>1).当同一个应用程序或者不同应用程序中的多个事务在同一个数据集上并发执行时, 可能会出现许多意外的问题</p>
<p>2).并发事务所导致的问题可以分为下面三种类型:</p>
<p>脏读: 对于两个事物 T1, T2, T1  读取了已经被 T2 更新但还没有被提交的字段. 之后, 若 T2 回滚, T1读取的内容就是临时且无效的.</p>
<p>不可重复读:对于两个事物 T1, T2, T1  读取了一个字段, 然后 T2 更新了该字段. 之后, T1再次读取同一个字段, 值就不同了.</p>
<p>幻读:对于两个事物 T1, T2, T1  从一个表中读取了一个字段, 然后 T2 在该表中插入了一些新的行. 之后, 如果 T1 再次读取同一个表, 就会多出几行.</p>
</blockquote>
<p>1).从理论上来说, 事务应该彼此完全隔离, 以避免并发事务所导致的问题. 然而, 那样会对性能产生极大的影响, 因为事务必须按顺序运行. </p>
<p>2).在实际开发中, 为了提升性能, 事务会以较低的隔离级别运行.</p>
<p>3).事务的隔离级别可以通过隔离事务属性指定</p>
<p>4).Spring 支持的事务隔离级别</p>
<p><img  src="E:/ftp%E8%B5%84%E6%96%99/note/8.SSM/1.Spring/%E8%AF%BE%E4%BB%B6/image/image-20200713030831721.png"  ><span class="image-caption">image-20200713030831721</span></p>
<p>5).事务的隔离级别要得到底层数据库引擎的支持, 而不是应用程序或者框架的支持.</p>
<p>Oracle 支持的 2 种事务隔离级别：READ_COMMITED , SERIALIZABLE</p>
<p>Mysql 支持以上 4种事务隔离级别.</p>
<p>6).设置隔离事务属性</p>
<p>用 @Transactional 注解声明式地管理事务时可以在 @Transactional 的 isolation 属性中设置隔离级别.</p>
<p><img  src="E:/ftp%E8%B5%84%E6%96%99/note/8.SSM/1.Spring/%E8%AF%BE%E4%BB%B6/image/wpsjXDKhZ.png"  ><span class="image-caption">img</span></p>
<h4 id="3）、设置回滚事务属性"><a href="#3）、设置回滚事务属性" class="headerlink" title="3）、设置回滚事务属性"></a>3）、设置回滚事务属性</h4><p>1).<strong>默认情况下只有未检查异常(RuntimeException和Error类型的异常)会导致事务回滚. 而受检查异常不会.</strong></p>
<p>2).事务的回滚规则可以通过 @Transactional 注解的 <strong>rollbackFor</strong> 和 <strong>noRollbackFor</strong> 属性来定义. 这两个属性被声明为 Class[] 类型的, 因此可以为这两个属性指定多个异常类.</p>
<p>rollbackFor:  遇到时必须进行回滚</p>
<p><img  src="E:/ftp%E8%B5%84%E6%96%99/note/8.SSM/1.Spring/%E8%AF%BE%E4%BB%B6/image/wpsgqn01n.png"  ><span class="image-caption">img</span></p>
<h4 id="4）、超时和只读属性"><a href="#4）、超时和只读属性" class="headerlink" title="4）、超时和只读属性"></a>4）、超时和只读属性</h4><p>1.由于事务可以在行和表上获得锁,  因此长事务会占用资源, 并对整体性能产生影响. </p>
<p>2.如果一个事物只读取数据但不做修改, 数据库引擎可以对这个事务进行优化.</p>
<p>3.超时事务属性: timeout属性，事务在强制回滚之前可以保持多久. 这样可以防止长期运行的事务占用资源.</p>
<p>4.只读事务属性: readOnly属性为true时，表示这个事务只读取数据但不更新数据, 这样可以帮助数据库引擎优化事务.</p>
<p>5.设置超时和只读事务属性</p>
<p>超时和只读属性可以在 @Transactional 注解中定义.超时属性以秒为单位来计算.</p>
<p><img  src="E:/ftp%E8%B5%84%E6%96%99/note/8.SSM/1.Spring/%E8%AF%BE%E4%BB%B6/image/wpsW0UVa6.png"  ><span class="image-caption">img</span></p>
<h3 id="4-4-案例"><a href="#4-4-案例" class="headerlink" title="4.4 案例"></a>4.4 案例</h3><blockquote>
<p>需求：</p>
<p>1).接口BookShopDAO中:</p>
<p>&#x2F;&#x2F;根据书号获取书的单价   </p>
<p>public int  findPriceByBookId(int bookId);</p>
<p>&#x2F;&#x2F;根据书号更新书的库存,使书号对应的库存减1  </p>
<p>public void updateStock(int bookId);</p>
<p>&#x2F;&#x2F;根据用户名更新用户余额,使username的balance-price</p>
<p>public void updateAccount(String username,int price);</p>
<p>2).接口BookShopService中：</p>
<p>&#x2F;&#x2F;根据书号和用户名购买书:</p>
<p>&#x2F;&#x2F;一个用户一次只能买一本书（操作：1.账户余额减去书的单价 2.书的库存减1）</p>
<p>public void purchase(String username,int bookId);</p>
</blockquote>
<p><img  src="E:/ftp%E8%B5%84%E6%96%99/note/8.SSM/1.Spring/%E8%AF%BE%E4%BB%B6/image/1624209924680.png"  ><span class="image-caption">1624209924680</span></p>
<blockquote>
<p>导入sql文件，初始化数据：表结构创建 t_account账户表  t_book书表  t_stock书的库存表</p>
</blockquote>
<h4 id="dao层"><a href="#dao层" class="headerlink" title="dao层"></a>dao层</h4><p>IBookShopDao接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.cm.ch06.trans.dao;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IBookShopDao</span> &#123;<br><br>	<span class="hljs-comment">//根据bookId获取书的价格</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">selectPrice</span><span class="hljs-params">(<span class="hljs-type">int</span> bookId)</span>;<br>	<span class="hljs-comment">//根据bookId更新库存</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">updateStock</span><span class="hljs-params">(<span class="hljs-type">int</span> bookId)</span>;<br>	<span class="hljs-comment">//根据username,price更新账户余额</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">updateBalance</span><span class="hljs-params">(String username, <span class="hljs-type">int</span> price)</span>;<br>	<br>&#125;<br><br></code></pre></td></tr></table></figure>



<p>BookShopDaoImpl 类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.cm.ch06.trans.dao;<br><br><span class="hljs-keyword">import</span> javax.annotation.Resource;<br><br><span class="hljs-keyword">import</span> com.cm.ch06.trans.exception.AccountException;<br><span class="hljs-keyword">import</span> com.cm.ch06.trans.exception.BookStockException;<br><span class="hljs-keyword">import</span> org.springframework.jdbc.core.JdbcTemplate;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Repository;<br><br><span class="hljs-meta">@Repository(&quot;bookShopDao&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BookShopDaoImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IBookShopDao</span> &#123;<br>	<span class="hljs-meta">@Resource</span><br>	<span class="hljs-keyword">private</span> JdbcTemplate jdbcTemplate;<br>	<br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">selectPrice</span><span class="hljs-params">(<span class="hljs-type">int</span> bookId)</span> &#123;<br>		<span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;select price from t_book where bookId = ?&quot;</span>;<br>		<span class="hljs-type">Integer</span> <span class="hljs-variable">price</span> <span class="hljs-operator">=</span> jdbcTemplate.queryForObject(sql, Integer.class, bookId);<br>		<span class="hljs-keyword">return</span> price;<br>	&#125;<br><br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">updateStock</span><span class="hljs-params">(<span class="hljs-type">int</span> bookId)</span> &#123;<br>		<span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;select stock from t_stock where bookId=?&quot;</span>;<br>		<span class="hljs-type">int</span> <span class="hljs-variable">stock</span> <span class="hljs-operator">=</span> jdbcTemplate.queryForObject(s, Integer.class, bookId);<br>		<span class="hljs-keyword">if</span>(stock&lt;=<span class="hljs-number">0</span>)&#123;<br>			<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BookStockException</span>(<span class="hljs-string">&quot;库存不足!!!&quot;</span>);<br>		&#125;<br>		<br>		<span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;update t_stock set stock=stock-1 where bookId=?&quot;</span>;<br>		jdbcTemplate.update(sql, bookId);<br>	&#125;<br><br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">updateBalance</span><span class="hljs-params">(String username, <span class="hljs-type">int</span> price)</span> &#123;<br>		<span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;select balance from t_account where username=?&quot;</span>;<br>		<span class="hljs-type">Integer</span> <span class="hljs-variable">balance</span> <span class="hljs-operator">=</span> jdbcTemplate.queryForObject(s, Integer.class, username);<br>		<span class="hljs-keyword">if</span>(balance&lt;price)&#123;<br>			<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AccountException</span>(<span class="hljs-string">&quot;账户余额不足!!!&quot;</span>);<br>		&#125;<br>		<br>		<span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;update t_account set balance=balance-? where username=?&quot;</span>;<br>		jdbcTemplate.update(sql, price,username);<br>	&#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure>



<h4 id="service层"><a href="#service层" class="headerlink" title="service层"></a>service层</h4><p>ICashierService 接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.cm.ch06.trans.service;<br><br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ICashierService</span> &#123;<br><br>	<span class="hljs-comment">//客户的结账</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">cash</span><span class="hljs-params">(String username, List&lt;Integer&gt; bookIds)</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>



<p>IBookShopService 接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.cm.ch06.trans.service;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IBookShopService</span> &#123;<br><br>	<span class="hljs-comment">//通过账户名及书号购买书</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">purchase</span><span class="hljs-params">(String username, <span class="hljs-type">int</span> bookId)</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>



<p>CashierServiceImpl 类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.cm.ch06.trans.service;<br><br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">import</span> javax.annotation.Resource;<br><br><span class="hljs-keyword">import</span> org.springframework.stereotype.Service;<br><span class="hljs-keyword">import</span> org.springframework.transaction.annotation.Transactional;<br><br><span class="hljs-meta">@Service(&quot;cashierService&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CashierServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ICashierService</span> &#123;<br>	<span class="hljs-meta">@Resource</span><br>	<span class="hljs-keyword">private</span> IBookShopService bookShopService;<br>	<br>	<span class="hljs-meta">@Transactional</span><br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">cash</span><span class="hljs-params">(String username, List&lt;Integer&gt; bookIds)</span> &#123;<br>		<span class="hljs-keyword">for</span> (Integer bookId : bookIds) &#123;<br>			bookShopService.purchase(username, bookId);<br>		&#125;<br>	&#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure>



<p>BookShopServiceImpl 类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.cm.ch06.trans.service;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.sql.SQLException;<br><br><span class="hljs-keyword">import</span> javax.annotation.Resource;<br><br><span class="hljs-keyword">import</span> com.cm.ch06.trans.dao.IBookShopDao;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Service;<br><span class="hljs-keyword">import</span> org.springframework.transaction.annotation.Isolation;<br><span class="hljs-keyword">import</span> org.springframework.transaction.annotation.Propagation;<br><span class="hljs-keyword">import</span> org.springframework.transaction.annotation.Transactional;<br><br><span class="hljs-meta">@Service(&quot;bookShopService&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BookShopServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IBookShopService</span> &#123;<br>	<span class="hljs-meta">@Resource</span><br>	<span class="hljs-keyword">private</span> IBookShopDao bookShopDao;<br>	<br>	<br>	<span class="hljs-comment">//支持注解式事务管理</span><br>	<span class="hljs-meta">@Transactional(propagation=Propagation.REQUIRES_NEW,</span><br><span class="hljs-meta">			isolation=Isolation.READ_COMMITTED,</span><br><span class="hljs-meta">			rollbackFor=&#123;IOException.class,SQLException.class&#125;,</span><br><span class="hljs-meta">			noRollbackFor=&#123;ArithmeticException.class&#125;,</span><br><span class="hljs-meta">			readOnly=false,</span><br><span class="hljs-meta">			timeout=3)</span><br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">purchase</span><span class="hljs-params">(String username, <span class="hljs-type">int</span> bookId)</span> &#123;<br><span class="hljs-comment">//		try &#123;</span><br><span class="hljs-comment">//			Thread.sleep(5000);</span><br><span class="hljs-comment">//		&#125; catch (InterruptedException e) &#123;</span><br><span class="hljs-comment">//			e.printStackTrace();</span><br><span class="hljs-comment">//		&#125;</span><br>		<span class="hljs-type">int</span> <span class="hljs-variable">price</span> <span class="hljs-operator">=</span> bookShopDao.selectPrice(bookId);<br>		bookShopDao.updateStock(bookId);<br>		bookShopDao.updateBalance(username, price);<br>	&#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure>



<h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h4><p>1).只有RuntimeException的异常并且没有被try catch处理的异常才会事务回滚</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BookStockException</span> <span class="hljs-keyword">extends</span>  <span class="hljs-title class_">RuntimeException</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BookStockException</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BookStockException</span><span class="hljs-params">(String message)</span> &#123;<br>        <span class="hljs-built_in">super</span>(message);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AccountException</span> <span class="hljs-keyword">extends</span>  <span class="hljs-title class_">RuntimeException</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">AccountException</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">AccountException</span><span class="hljs-params">(String message)</span> &#123;<br>        <span class="hljs-built_in">super</span>(message);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<p>2).若异常继承了Exception，可以在service向上抛出，不要try..catch，通过以下方式指定Exception类型，可以回滚即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Transactional(rollbackFor=&#123;Exception.class&#125;)</span><br></code></pre></td></tr></table></figure>



<h4 id="测试类-TestSpringTrans"><a href="#测试类-TestSpringTrans" class="headerlink" title="测试类 TestSpringTrans"></a>测试类 TestSpringTrans</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TransactionTest</span> &#123;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">AnnotationConfigApplicationContext</span> <span class="hljs-variable">ac</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotationConfigApplicationContext</span>(MyConfig.class);<br>        <br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> ac.getBeanDefinitionCount();<br>        System.out.println(count);  <span class="hljs-comment">//17</span><br>        String[] names = ac.getBeanDefinitionNames();<br>        <span class="hljs-comment">//dataSource  jdbcTemplate  platformTransactionManager  myConfig  bookShopDaoImpl  bookShopServiceImpl</span><br>        System.out.println(Arrays.toString(names));<br>        <br>        <span class="hljs-type">BookShopServiceImpl</span> <span class="hljs-variable">service</span> <span class="hljs-operator">=</span> ac.getBean(BookShopServiceImpl.class);<br>        service.purchase(<span class="hljs-string">&quot;张三&quot;</span>,<span class="hljs-number">1</span>);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="5-Spring中使用xml文件方式配置事务"><a href="#5-Spring中使用xml文件方式配置事务" class="headerlink" title="5.Spring中使用xml文件方式配置事务"></a>5.Spring中使用xml文件方式配置事务</h2><h3 id="5-1-用事务通知声明式地管理事务"><a href="#5-1-用事务通知声明式地管理事务" class="headerlink" title="5.1 用事务通知声明式地管理事务"></a>5.1 用事务通知声明式地管理事务</h3><p>1).事务管理是一种横切关注点</p>
<p>2).为了在 Spring 2.x 中启用声明式事务管理, 可以通过 tx Schema 中定义的<a href="tx:advice">tx:advice</a> 元素声明事务通知, 为此必须事先将这个 Schema 定义添加到 <beans> 根元素中去.</p>
<p>3).声明了事务通知后, 就需要将它与切入点关联起来. 由于事务通知是在 <a href="aop:config">aop:config</a> 元素外部声明的, 所以它无法直接与切入点产生关联. 所以必须在 <a href="aop:config">aop:config</a> 元素中声明一个增强器通知与切入点关联起来.</p>
<p>4).由于 Spring AOP 是基于代理的方法, 所以只能增强公共方法. 因此, 只有公有方法才能通过 Spring AOP 进行事务管理.</p>
<h3 id="5-2-用事务通知声明式地管理事务示例代码"><a href="#5-2-用事务通知声明式地管理事务示例代码" class="headerlink" title="5.2 用事务通知声明式地管理事务示例代码"></a>5.2 用事务通知声明式地管理事务示例代码</h3><p><img  src="E:/ftp%E8%B5%84%E6%96%99/note/8.SSM/1.Spring/%E8%AF%BE%E4%BB%B6/image/1624210226913.png"  ><span class="image-caption">1624210226913</span></p>
<p><img  src="E:/ftp%E8%B5%84%E6%96%99/note/8.SSM/1.Spring/%E8%AF%BE%E4%BB%B6/image/1624210239022.png"  ><span class="image-caption">1624210239022</span></p>
<h3 id="5-3-在事务通知中-可以在-tx-method-元素中配置传播属性"><a href="#5-3-在事务通知中-可以在-tx-method-元素中配置传播属性" class="headerlink" title="5.3 在事务通知中, 可以在 tx:method 元素中配置传播属性"></a>5.3 在事务通知中, 可以在 <a href="tx:method">tx:method</a> 元素中配置传播属性</h3><p><img  src="E:/ftp%E8%B5%84%E6%96%99/note/8.SSM/1.Spring/%E8%AF%BE%E4%BB%B6/image/1624210263240.png"  ><span class="image-caption">1624210263240</span></p>
<h3 id="5-4-在事务通知中-可以在-tx-method-元素中指定隔离级别"><a href="#5-4-在事务通知中-可以在-tx-method-元素中指定隔离级别" class="headerlink" title="5.4 在事务通知中, 可以在 tx:method 元素中指定隔离级别"></a>5.4 在事务通知中, 可以在 <a href="tx:method">tx:method</a> 元素中指定隔离级别</h3><p><img  src="E:/ftp%E8%B5%84%E6%96%99/note/8.SSM/1.Spring/%E8%AF%BE%E4%BB%B6/image/1624210283686.png"  ><span class="image-caption">1624210283686</span></p>
<h3 id="5-5-在事务通知中-可以在-tx-method-元素中设置回滚事务属性"><a href="#5-5-在事务通知中-可以在-tx-method-元素中设置回滚事务属性" class="headerlink" title="5.5 在事务通知中, 可以在 tx:method 元素中设置回滚事务属性"></a>5.5 在事务通知中, 可以在 <a href="tx:method">tx:method</a> 元素中设置回滚事务属性</h3><p>如果有不止一种异常, 用逗号分隔.</p>
<p><img  src="E:/ftp%E8%B5%84%E6%96%99/note/8.SSM/1.Spring/%E8%AF%BE%E4%BB%B6/image/1624210311953.png"  ><span class="image-caption">1624210311953</span></p>
<h3 id="5-6-在事务通知中-在-tx-method-元素中设置超时和只读属性"><a href="#5-6-在事务通知中-在-tx-method-元素中设置超时和只读属性" class="headerlink" title="5.6 在事务通知中, 在 tx:method 元素中设置超时和只读属性"></a>5.6 在事务通知中, 在 <a href="tx:method">tx:method</a> 元素中设置超时和只读属性</h3><p><img  src="E:/ftp%E8%B5%84%E6%96%99/note/8.SSM/1.Spring/%E8%AF%BE%E4%BB%B6/image/1624210329897.png"  ><span class="image-caption">1624210329897</span></p>
<h1 id="五-Spring5-新特性介绍"><a href="#五-Spring5-新特性介绍" class="headerlink" title="五.Spring5 新特性介绍"></a>五.Spring5 新特性介绍</h1><h2 id="一-Spring-FrameWork-5-0新的功能"><a href="#一-Spring-FrameWork-5-0新的功能" class="headerlink" title="一.Spring FrameWork 5.0新的功能"></a>一.Spring FrameWork 5.0新的功能</h2><p>升级到新版本的框架可以参考。<a href="https://github.com/spring-projects/spring-framework/wiki/Migrating-from-earlier-versions-of-the-Spring-Framework">Spring git</a>。</p>
<h3 id="1-JDK-8-和Java-EE7-以上版本"><a href="#1-JDK-8-和Java-EE7-以上版本" class="headerlink" title="1.JDK 8+和Java EE7+以上版本"></a>1.JDK 8+和Java EE7+以上版本</h3><ul>
<li>整个框架的代码基于java8</li>
<li>通过使用泛型等特性提高可读性</li>
<li>对java8提高直接的代码支撑</li>
<li>运行时兼容JDK9</li>
<li>Java EE 7API需要Spring相关的模块支持</li>
<li>运行时兼容Java EE8 API</li>
<li>取消的包,类和方法</li>
<li>包 beans.factory.access</li>
<li>包 dbc.support.nativejdbc</li>
<li>从spring-aspects 模块移除了包mock.staicmock,不在提AnnotationDrivenStaticEntityMockingControl支持</li>
<li>许多不建议使用的类和方法在代码库中删除</li>
</ul>
<h3 id="2-核心特性"><a href="#2-核心特性" class="headerlink" title="2.核心特性"></a>2.核心特性</h3><p>JDK8的增强：</p>
<ul>
<li>访问Resuouce时提供getFile或和isFile防御式抽象</li>
<li>有效的方法参数访问基于java 8反射增强</li>
<li>在Spring核心接口中增加了声明default方法的支持一贯使用JDK7 Charset和StandardCharsets的增强</li>
<li>兼容JDK9</li>
<li>Spring 5.0框架自带了通用的日志封装</li>
<li>持续实例化via构造函数(修改了异常处理)</li>
<li>Spring 5.0框架自带了通用的日志封装</li>
<li>spring-jcl替代了通用的日志，仍然支持可重写</li>
<li>自动检测log4j2.xml, SLF4J, JUL（java.util.Logging）而不是其他的支持</li>
<li>访问Resuouce时提供getFile或和isFile防御式抽象</li>
<li>基于NIO的readableChannel也提供了这个新特性</li>
</ul>
<h3 id="3-核心容器"><a href="#3-核心容器" class="headerlink" title="3.核心容器"></a>3.核心容器</h3><ul>
<li>支持候选组件索引(也可以支持环境变量扫描)</li>
<li>支持@Nullable注解</li>
<li>函数式风格GenericApplicationContext&#x2F;AnnotationConfigApplicationContext</li>
<li>基本支持bean API注册</li>
<li>在接口层面使用CGLIB动态代理的时候，提供事物，缓存，异步注解检测</li>
<li>XML配置作用域流式</li>
<li>Spring WebMVC</li>
<li>全部的Servlet 3.1 签名支持在Spring-provied Filter实现</li>
<li>在Spring MVC Controller方法里支持Servlet4.0 PushBuilder参数</li>
<li>多个不可变对象的数据绑定(Kotlin&#x2F;Lombok&#x2F;@ConstructorPorties)</li>
<li>支持jackson2.9</li>
<li>支持JSON绑定API</li>
<li>支持protobuf3</li>
<li>支持Reactor3.1 Flux和Mono</li>
</ul>
<h3 id="4-SpringWebFlux"><a href="#4-SpringWebFlux" class="headerlink" title="4.SpringWebFlux"></a>4.SpringWebFlux</h3><ul>
<li>新的spring-webflux模块，一个基于reactive的spring-webmvc，完全的异步非阻塞，旨在使用enent-loop执行模型和传统的线程池模型。</li>
<li>Reactive说明在spring-core比如编码和解码</li>
<li>spring-core相关的基础设施，比如Encode 和Decoder可以用来编码和解码数据流；DataBuffer 可以使用java ByteBuffer或者Netty ByteBuf;ReactiveAdapterRegistry可以对相关的库提供传输层支持。</li>
<li>在spring-web包里包含HttpMessageReade和HttpMessageWrite</li>
</ul>
<h3 id="5-测试方面的改进"><a href="#5-测试方面的改进" class="headerlink" title="5.测试方面的改进"></a>5.测试方面的改进</h3><ul>
<li>完成了对JUnit 5’s Juptier编程和拓展模块在Spring TestContext框架</li>
<li>SpringExtension:是JUnit多个可拓展API的一个实现，提供了对现存Spring TestContext Framework的支持，使用@ExtendWith(SpringExtension.class)注解引用。</li>
<li>@SpringJunitConfig:一个复合注解</li>
<li>@ExtendWith(SpringExtension.class) 来源于Junit Jupit</li>
<li>@ContextConfiguration 来源于Spring TestContext框架</li>
<li>@DisabledIf 如果提供的该属性值为true的表达或占位符，信号：注解的测试类或测试方法被禁用</li>
<li>在Spring TestContext框架中支持并行测试</li>
<li>具体细节查看Test 章节 通过SpringRunner在Sring TestContext框架中支持TestNG, Junit5,新的执行之前和之后测试回调。</li>
<li>在testexecutionlistener API和testcontextmanager新beforetestexecution()和aftertestexecution()回调。MockHttpServletRequest新增了getContentAsByteArray()和getContentAsString()方法来访问请求体</li>
<li>如果字符编码被设置为mock请求，在print()和log()方法中可以打印Spring MVC Test的redirectedUrl()和forwardedUrl()方法支持带变量表达式URL模板。</li>
<li>XMLUnit 升级到了2.3版本。</li>
</ul>
<h2 id="二-新功能的使用"><a href="#二-新功能的使用" class="headerlink" title="二.新功能的使用"></a>二.新功能的使用</h2><p>整个 Spring5 框架的代码基于 Java8，运行时兼容 JDK9，许多不建议使用的类和方法在代码库中删除</p>
<h3 id="1-Spring-5-0-框架自带了通用的日志封装"><a href="#1-Spring-5-0-框架自带了通用的日志封装" class="headerlink" title="1.Spring 5.0 框架自带了通用的日志封装"></a>1.Spring 5.0 框架自带了通用的日志封装</h3><p>（1）Spring5 已经移除 Log4jConfigListener，官方建议使用 Log4j2 </p>
<p>（2）Spring5 框架整合 Log4j2</p>
<p><strong>第一步：修改pom.xml，引入依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 引入 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>log4j-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.11.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>log4j-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.11.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.7.30<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>log4j-slf4j-impl<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.11.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>



<p><strong>第二步 创建 log4j2.xml 配置文件</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-comment">&lt;!--日志级别以及优先级排序: OFF &gt; FATAL &gt; ERROR &gt; WARN &gt; INFO &gt; DEBUG &gt; TRACE &gt; </span><br><span class="hljs-comment">ALL --&gt;</span><br><span class="hljs-comment">&lt;!--Configuration 后面的 status 用于设置 log4j2 自身内部的信息输出，可以不设置，</span><br><span class="hljs-comment">当设置成 trace 时，可以看到 log4j2 内部各种详细输出--&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span> <span class="hljs-attr">status</span>=<span class="hljs-string">&quot;INFO&quot;</span>&gt;</span><br>     <span class="hljs-comment">&lt;!--先定义所有的 appender--&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">appenders</span>&gt;</span><br>         <span class="hljs-comment">&lt;!--输出日志信息到控制台--&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">console</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;Console&quot;</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;SYSTEM_OUT&quot;</span>&gt;</span><br>             <span class="hljs-comment">&lt;!--控制日志输出的格式--&gt;</span><br>             <span class="hljs-tag">&lt;<span class="hljs-name">PatternLayout</span> <span class="hljs-attr">pattern</span>=<span class="hljs-string">&quot;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%t] %-</span></span><br><span class="hljs-string"><span class="hljs-tag">        5level %logger&#123;36&#125; - %msg%n&quot;</span>/&gt;</span><br>         <span class="hljs-tag">&lt;/<span class="hljs-name">console</span>&gt;</span><br>     <span class="hljs-tag">&lt;/<span class="hljs-name">appenders</span>&gt;</span><br> <span class="hljs-comment">&lt;!--然后定义 logger，只有定义 logger 并引入的 appender，appender 才会生效--&gt;</span><br> <span class="hljs-comment">&lt;!--root：用于指定项目的根日志，如果没有单独指定 Logger，则会使用 root 作为</span><br><span class="hljs-comment">默认的日志输出--&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">loggers</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">root</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;info&quot;</span>&gt;</span><br>    	 <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;Console&quot;</span>/&gt;</span><br>     <span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">loggers</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure>



<p><strong>第三步 编写测试类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.slf4j.Logger;<br><span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LogTest</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(LogTest.class);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        logger.info(<span class="hljs-string">&quot;LogTest info级别&quot;</span>);<br>        logger.warn(<span class="hljs-string">&quot;LogTest warn级别&quot;</span>);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="2-Spring5框架核心容器支持-Nullable注解"><a href="#2-Spring5框架核心容器支持-Nullable注解" class="headerlink" title="2.Spring5框架核心容器支持@Nullable注解"></a>2.Spring5框架核心容器支持@Nullable注解</h3><p>（1）@Nullable 注解可以使用在方法上面，属性上面，参数上面，表示方法返回可以为空，属性值可以 </p>
<p>为空，参数值可以为空 </p>
<p>（2）注解用在方法上面，方法返回值可以为空</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Nullable</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">getId</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure>

<p>（3）注解使用在方法参数里面，方法参数可以为空</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">regist</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> String name)</span>&#123;<br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>（4）注解使用在属性上面，属性值可以为空</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Nullable</span><br><span class="hljs-keyword">private</span> String name;<br></code></pre></td></tr></table></figure>



<h3 id="3-Spring5支持整合JUnit5"><a href="#3-Spring5支持整合JUnit5" class="headerlink" title="3.Spring5支持整合JUnit5"></a>3.Spring5支持整合JUnit5</h3><h4 id="3-1-Spring5整合JUnit4"><a href="#3-1-Spring5整合JUnit4" class="headerlink" title="3.1 Spring5整合JUnit4"></a>3.1 Spring5整合JUnit4</h4><p><strong>第一步 修改pom.xml，添加spring-test依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-test --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.3.13<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.12<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>



<p><strong>第二步 创建测试类，使用注解方式完成</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.junit.Test;<br><span class="hljs-keyword">import</span> org.junit.runner.RunWith;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.test.context.ContextConfiguration;<br><span class="hljs-keyword">import</span> org.springframework.test.context.junit4.SpringJUnit4ClassRunner;<br><br><span class="hljs-comment">//JUnit4版本</span><br><span class="hljs-meta">@RunWith(SpringJUnit4ClassRunner.class)</span><br><span class="hljs-meta">@ContextConfiguration(&quot;classpath:spring.xml&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JTest4</span> &#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="3-2-Spring5整合JUnit5"><a href="#3-2-Spring5整合JUnit5" class="headerlink" title="3.2 Spring5整合JUnit5"></a>3.2 Spring5整合JUnit5</h4><p><strong>第一步 修改pom.xml，添加JUnit5依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.junit.jupiter/junit-jupiter-api --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.junit.jupiter<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit-jupiter-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.7.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>



<p><strong>第二步 创建测试类，使用注解完成</strong> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.junit.jupiter.api.Test;<br><span class="hljs-keyword">import</span> org.junit.jupiter.api.extension.ExtendWith;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.test.context.ContextConfiguration;<br><span class="hljs-keyword">import</span> org.springframework.test.context.junit.jupiter.SpringExtension;<br><br><span class="hljs-comment">//JUnit5版本</span><br><span class="hljs-meta">@ExtendWith(SpringExtension.class)</span><br><span class="hljs-meta">@ContextConfiguration(&quot;classpath:spring.xml&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JTest5</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="3-3-使用一个复合注解替代上面两个注解完成整合"><a href="#3-3-使用一个复合注解替代上面两个注解完成整合" class="headerlink" title="3.3 使用一个复合注解替代上面两个注解完成整合"></a>3.3 使用一个复合注解替代上面两个注解完成整合</h4><p><strong>可以使用组合注解@SpringJUnitConfig</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.junit.jupiter.api.Test;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.test.context.junit.jupiter.SpringJUnitConfig;<br><br><span class="hljs-comment">//JUnit5版本，locations属性，指定spring的配置文件</span><br><span class="hljs-meta">@SpringJUnitConfig(locations = &quot;classpath:spring.xml&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JTest5</span> &#123;<br><br>&#125;<br><br><span class="hljs-comment">//classes属性，指定spring的配置类</span><br><span class="hljs-meta">@SpringJUnitConfig(classes = MyConfig.classs)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Junit5Test</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> User user;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">//User&#123;name = 李四, pwd = 123&#125;</span><br>        System.out.println(user);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>spring初识</title>
    <url>/2023/04/14/spring%E5%88%9D%E8%AF%86/</url>
    <content><![CDATA[<img src="E:/ftp%E8%B5%84%E6%96%99/note/8.SSM/1.Spring/%E8%AF%BE%E4%BB%B6/image/igeek.jpg" style="zoom:50%;" />

<h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><h1 id="一-Spring初识"><a href="#一-Spring初识" class="headerlink" title="一.Spring初识"></a>一.Spring初识</h1><h2 id="1-Spring是什么？"><a href="#1-Spring是什么？" class="headerlink" title="1.Spring是什么？"></a>1.Spring是什么？</h2><p>1.1 Spring是一个开源框架</p>
<p>1.2 Spring为简化企业级应用开发而生，使用Spring可以使简单的JavaBean实现以前只有EJB才能实现的功能</p>
<p>1.3 Spring是一个&#x3D;&#x3D;IOC反转控制&#x3D;&#x3D;和&#x3D;&#x3D;AOP面向切面编程&#x3D;&#x3D;容器框架</p>
<h2 id="x3D-x3D-2-具体描述Spring-x3D-x3D"><a href="#x3D-x3D-2-具体描述Spring-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;2.具体描述Spring&#x3D;&#x3D;"></a><strong>&#x3D;&#x3D;2.具体描述Spring&#x3D;&#x3D;</strong></h2><p>2.1 <strong>轻量级</strong>：并不是说Spring的jar包有多大，而是说Spring是非侵入性的（即当用Spring时，不需要去实现Spring给提供的任何接口，不需要去继承它的任何父类，可以享用它的功能）基于Spring开发的应用中的对象可以不依赖于Spring的API</p>
<p>2.2 <strong>依赖注入</strong>（DI—dependency  injection、IOC）</p>
<p>2.3 <strong>面向切面编程</strong>（AOP—aspect oriented programming）</p>
<p>2.4 <strong>容器</strong>：Spring是一个容器，因为它包含并且管理应用对象的生命周期</p>
<p>2.5 <strong>框架</strong>：Spring实现了使用简单的组件配置组合成一个复杂的应用。在Spring中可以使用XML和Java注解组合这些对象。</p>
<p>2.6 <strong>一站式</strong>：在IOC和AOP的基础上可以整合各种企业应用的开源框架（如Struts2、Hibernate、Mybatis）和优秀的第三方类库（实际上Spring自身也提供了展现层的Spring MVC和持久层的Spring JDBC）</p>
<h2 id="3-Spring-模块"><a href="#3-Spring-模块" class="headerlink" title="3.Spring 模块"></a>3.Spring 模块</h2><p>Spring官网： <a href="https://spring.io/">https://spring.io/</a></p>
<p>mvn仓库地址：<a href="https://mvnrepository.com/">https://mvnrepository.com/</a></p>
<p><img src="E:/ftp%E8%B5%84%E6%96%99/note/8.SSM/1.Spring/%E8%AF%BE%E4%BB%B6/image/1624203387935.bmp"> </p>
<blockquote>
<p>Core Container核心容器       </p>
<p>AOP  Aspects面向切面编程    </p>
<p>Instrumentation整合    </p>
<p>Messaging消息</p>
<p>Test 测试</p>
</blockquote>
<h2 id="4-搭建-Spring-开发环境"><a href="#4-搭建-Spring-开发环境" class="headerlink" title="4.搭建 Spring 开发环境"></a>4.搭建 Spring 开发环境</h2><p><strong>4.1  修改pom.xml文件，引入相关依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--  Spring依赖 --&gt;</span><br><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-beans --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-beans<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.3.13<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-context --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-context<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.3.13<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-core --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.3.13<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>



<p><strong>4.2 新建Spring 的配置文件</strong></p>
<p> 一个典型的 Spring 项目需要创建一个或多个 Bean 配置文件, 这些配置文件用于在 Spring IOC 容器里配置 Bean。</p>
<p> Bean 的配置文件可以放在 classpath下：</p>
<p><strong>新建resources文件夹</strong></p>
<p><img  src="E:/ftp%E8%B5%84%E6%96%99/note/8.SSM/1.Spring/%E8%AF%BE%E4%BB%B6/image/image-20200712232651926.png"  ><span class="image-caption">image-20200712232651926</span></p>
<p><strong>将resources文件夹设置为Resources Root</strong></p>
<p><img  src="E:/ftp%E8%B5%84%E6%96%99/note/8.SSM/1.Spring/%E8%AF%BE%E4%BB%B6/image/image-20200712232929343.png"  ><span class="image-caption">image-20200712232929343</span></p>
<p><strong>新建spring的核心配置文件，一般默认命名为applicationContext.xml</strong></p>
<p><img  src="E:/ftp%E8%B5%84%E6%96%99/note/8.SSM/1.Spring/%E8%AF%BE%E4%BB%B6/image/image-20200712233144462.png"  ><span class="image-caption">image-20200712233144462</span></p>
<p><img  src="E:/ftp%E8%B5%84%E6%96%99/note/8.SSM/1.Spring/%E8%AF%BE%E4%BB%B6/image/image-20200712233845544.png"  ><span class="image-caption">image-20200712233845544</span></p>
<h2 id="5-创建-HelloWorld-java"><a href="#5-创建-HelloWorld-java" class="headerlink" title="5.创建 HelloWorld.java"></a>5.创建 HelloWorld.java</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.cm.spring.ch01;<br><br><br><span class="hljs-keyword">import</span> org.springframework.context.ApplicationContext;<br><br><span class="hljs-keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">  IOC控制反转：</span><br><span class="hljs-comment">  	原来自己创建对象，现在可以通过Spring容器来创建对象，我们从中获取对象</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloWorld</span> &#123;<br><br>	<span class="hljs-keyword">private</span> String userName;<br><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setUserName1</span><span class="hljs-params">(String username)</span>&#123;<br><br>		System.out.println(<span class="hljs-string">&quot;setUserName1：&quot;</span>+username);<br><br>		<span class="hljs-built_in">this</span>.userName =  username;<br><br>	&#125;<br><br>	<span class="hljs-keyword">public</span> <span class="hljs-title function_">HelloWorld</span><span class="hljs-params">()</span>&#123;<br><br>		System.out.println(<span class="hljs-string">&quot;构造方法。。。&quot;</span>);<br><br>	&#125;<br><br> 	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hello</span><span class="hljs-params">()</span>&#123;<br><br>		System.out.println(<span class="hljs-string">&quot;Hello: &quot;</span>+userName);<br><br>	&#125;<br><br>&#125;<br><br><br></code></pre></td></tr></table></figure>



<h2 id="6-配置-applicationContext-xml"><a href="#6-配置-applicationContext-xml" class="headerlink" title="6.配置 applicationContext.xml"></a>6.配置 applicationContext.xml</h2><p>在 xml 文件中通过 bean 节点来配置 bean实例</p>
<p><strong>6.1 其中id是Bean 的名称</strong></p>
<p>1).在 IOC 容器中必须是唯一的</p>
<p>2).若 id 没有指定，Spring 自动将全类名作为 Bean 的名字</p>
<p>3).id 可以指定多个名字，名字之间可用逗号、分号、或空格分隔</p>
<p><strong>6.2 属性注入</strong></p>
<p>1).属性注入即通过 setter 方法注入Bean 的属性值或依赖的对象</p>
<p>2).属性注入使用 <property> 元素, 使用 name 属性指定 Bean 的属性名称，value 属性或 <value> 子节点指定属性值 </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag"></span><br><span class="hljs-tag">	<span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag"></span><br><span class="hljs-tag">	<span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span><br><br>	<span class="hljs-comment">&lt;!-- 配置bean --&gt;</span><br><br>	<span class="hljs-comment">&lt;!-- class属性值：全类名是通过反射的方式，由Spring创建的HelloWorld的对象</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">		id用来标识创建的对象	</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">		name对应的是setXxx()中的xxx</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">		value是指将为类中的属性赋值</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">	 --&gt;</span><br><br>	<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;helloWorld&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.igeek.spring.ch01.HelloWorld&quot;</span>&gt;</span><br><br>		<span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;userName1&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Spring&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><br>	<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure>



<h2 id="7-测试"><a href="#7-测试" class="headerlink" title="7.测试"></a>7.测试</h2><p>ApplicationContext 的主要实现类：ClassPathXmlApplicationContext：从类路径下加载配置文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainTest</span>&#123;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>		<span class="hljs-comment">//1.创建HelloWorld的一个对象</span><br><br>		<span class="hljs-comment">//HelloWorld h = new HelloWorld();</span><br><br>		<span class="hljs-comment">//2.为userName属性赋值</span><br><br>		<span class="hljs-comment">//h.setUserName(&quot;zhangsan&quot;);</span><br><br>		<span class="hljs-comment">//h.hello();</span><br><br><br><br>		<span class="hljs-comment">//1.创建Spring的IOC容器对象</span><br><br>		<span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">ctx</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;applicationContext.xml&quot;</span>);<br><br>		<span class="hljs-comment">//2.从IOC容器中获取Bean实例</span><br><br>		<span class="hljs-type">HelloWorld</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> (HelloWorld)ctx.getBean(<span class="hljs-string">&quot;helloWorld&quot;</span>);<br><br>		System.out.println(h);<br><br>		<span class="hljs-comment">//3.调用方法</span><br><br>		h.hello();<br><br>	&#125;<br>  <br>&#125;<br></code></pre></td></tr></table></figure>



<h1 id="二-Spring的IOC"><a href="#二-Spring的IOC" class="headerlink" title="二.Spring的IOC"></a>二.Spring的IOC</h1><h2 id="2-1、Spring-IOC-amp-DI概述"><a href="#2-1、Spring-IOC-amp-DI概述" class="headerlink" title="2.1、Spring_IOC&amp;DI概述"></a>2.1、Spring_IOC&amp;DI概述</h2><h3 id="x3D-x3D-1-IOC和DI概述-x3D-x3D"><a href="#x3D-x3D-1-IOC和DI概述-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;1.IOC和DI概述&#x3D;&#x3D;"></a>&#x3D;&#x3D;1.IOC和DI概述&#x3D;&#x3D;</h3><blockquote>
<p>&#x3D;&#x3D;IOC(Inversion of Control)&#x3D;&#x3D;：其思想是反转资源获取的方向. 传统的资源查找方式要求组件向容器发起请求查找资源. 作为回应, 容器适时的返回资源. 而应用了 IOC 之后, 则是容器主动地将资源推送给它所管理的组件, 组件所要做的仅是选择一种合适的方式来接受资源. 这种行为也被称为查找的被动形式。</p>
</blockquote>
<blockquote>
<p>&#x3D;&#x3D;DI(Dependency Injection)&#x3D;&#x3D; ：— IOC 的另一种表述方式：即组件以一些预先定义好的方式(例如: setter 方法)接受来自如容器的资源注入. 相对于 IOC 而言，这种表述更直接</p>
</blockquote>
<h3 id="2-IOC思想发展"><a href="#2-IOC思想发展" class="headerlink" title="2.IOC思想发展"></a>2.IOC思想发展</h3><p>需求: 生成 HTML 或 PDF 格式的不同类型的报表.</p>
<blockquote>
<p>IOC 前生 – 分离接口与实现：耦合度最高的方式，因为在报表服务类中需要知道接口及其每个实现类的细节</p>
</blockquote>
<p><img  src="E:/ftp%E8%B5%84%E6%96%99/note/8.SSM/1.Spring/%E8%AF%BE%E4%BB%B6/image/wps4.jpg"  ><span class="image-caption">img</span></p>
<blockquote>
<p>IOC 前生 – 采用工厂设计模式</p>
</blockquote>
<p><img  src="E:/ftp%E8%B5%84%E6%96%99/note/8.SSM/1.Spring/%E8%AF%BE%E4%BB%B6/image/wps5.jpg"  ><span class="image-caption">img</span></p>
<blockquote>
<p>IOC – 采用反转控制</p>
</blockquote>
<p><img  src="E:/ftp%E8%B5%84%E6%96%99/note/8.SSM/1.Spring/%E8%AF%BE%E4%BB%B6/image/wps7.jpg"  ><span class="image-caption">img</span></p>
<h2 id="x3D-x3D-2-2、如何定义Bean-x3D-x3D"><a href="#x3D-x3D-2-2、如何定义Bean-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;2.2、如何定义Bean&#x3D;&#x3D;"></a>&#x3D;&#x3D;2.2、如何定义Bean&#x3D;&#x3D;</h2><h3 id="1-BeanFactory"><a href="#1-BeanFactory" class="headerlink" title="1.BeanFactory"></a>1.BeanFactory</h3><p>BeanFactory表示Bean工厂，BeanFactory会负责创建Bean，并且提供获取Bean的API。而ApplicationContext继承了BeanFactory。</p>
<p>BeanFactory 是 Spring 框架的基础设施，面向 Spring 本身；ApplicationContext 面向使用 Spring 框架的开发者，几乎所有的应用场合都直接使用 ApplicationContext 而非底层的 BeanFactory。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//BeanFactory</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">BeanFactory</span> &#123;<br>    ...<br>&#125;<br><br><span class="hljs-comment">//ListableBeanFactory</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ListableBeanFactory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BeanFactory</span> &#123;<br>    ...<br>&#125;<br><br><span class="hljs-comment">//ApplicationContext</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ApplicationContext</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">EnvironmentCapable</span>, ListableBeanFactory, HierarchicalBeanFactory, MessageSource, ApplicationEventPublisher, ResourcePatternResolver &#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>



<blockquote>
<p>其中，在Spring源码中，BeanFactory接口存在一个非常重要的实现类是：<strong>DefaultListableBeanFactory</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DefaultListableBeanFactory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractAutowireCapableBeanFactoryimplements</span> ConfigurableListableBeanFactory, BeanDefinitionRegistry, Serializable &#123;<br>    <br>    <span class="hljs-comment">/** Map of bean definition objects, keyed by bean name. */</span><br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, BeanDefinition&gt; beanDefinitionMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="hljs-number">256</span>);<br>    <br>    <span class="hljs-comment">/** List of bean definition names, in registration order. */</span><br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> List&lt;String&gt; beanDefinitionNames = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(<span class="hljs-number">256</span>);<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="2-ApplicationContext"><a href="#2-ApplicationContext" class="headerlink" title="2.ApplicationContext"></a>2.ApplicationContext</h3><p>ApplicationContext是个接口，实际上也是一个BeanFactory，不过比BeanFactory更加强大</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//ApplicationContext</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ApplicationContext</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">EnvironmentCapable</span>, ListableBeanFactory, HierarchicalBeanFactory, MessageSource, ApplicationEventPublisher, ResourcePatternResolver &#123;<br>    ...<br>&#125;<br><br><span class="hljs-comment">//1. HierarchicalBeanFactory：拥有获取父BeanFactory的功能</span><br><span class="hljs-comment">//2. ListableBeanFactory：拥有获取beanNames的功能</span><br><span class="hljs-comment">//3. ResourcePatternResolver：资源加载器，可以一次性获取多个资源（文件资源等等）</span><br><span class="hljs-comment">//4. EnvironmentCapable：可以获取运行时环境（没有设置运行时环境功能）</span><br><span class="hljs-comment">//5. ApplicationEventPublisher：拥有广播事件的功能（没有添加事件监听器的功能）</span><br><span class="hljs-comment">//6. MessageSource：拥有国际化功能</span><br></code></pre></td></tr></table></figure>



<p>ApplicationContext 的主要实现类</p>
<blockquote>
<p>AnnotationConfigApplicationContext：通过加载配置类，获得上下文对象</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AnnotationConfigApplicationContext</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">GenericApplicationContext</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">AnnotationConfigRegistry</span> &#123;<br>    ...<br>&#125;<br><br><span class="hljs-comment">//1. ConfigurableApplicationContext：继承了ApplicationContext接口，增加了，添加事件监听器、添加BeanFactoryPostProcessor、设置Environment，获取ConfigurableListableBeanFactory等功能</span><br><span class="hljs-comment">//2. AbstractApplicationContext：实现了ConfigurableApplicationContext接口</span><br><span class="hljs-comment">//3. GenericApplicationContext：继承了AbstractApplicationContext，实现了BeanDefinitionRegistry接口，拥有了所有ApplicationContext的功能，并且可以注册BeanDefinition，注意这个类中有一个属性(private final DefaultListableBeanFactory beanFactory;)</span><br><span class="hljs-comment">//4. AnnotationConfigRegistry：可以单独注册某个为类为BeanDefinition（可以处理该类上的@Configuration注解，已经可以处理@Bean注解），同时可以扫描</span><br><span class="hljs-comment">//5. AnnotationConfigApplicationContext：继承了GenericApplicationContext，实现了AnnotationConfigRegistry接口，拥有了以上所有的功能</span><br></code></pre></td></tr></table></figure>



<blockquote>
<p>ClassPathXmlApplicationContext：从类路径下(bin目录下)加载XML配置文件</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractXmlApplicationContext</span> &#123;<br>    ...<br>&#125;<br><br><span class="hljs-comment">//它也间接继承了AbstractApplicationContext，但是相对于AnnotationConfigApplicationContext而言，功能没有AnnotationConfigApplicationContext强大，比如不能注册BeanDefinition </span><br><br></code></pre></td></tr></table></figure>



<h3 id="3-BeanDefinition"><a href="#3-BeanDefinition" class="headerlink" title="3.BeanDefinition"></a>3.BeanDefinition</h3><p>BeanDefinition表示Bean定义，BeanDefinition中存在很多属性用来描述一个Bean的特点。</p>
<blockquote>
<p>class，表示Bean类型</p>
<p>scope，表示Bean作用域，单例或原型等</p>
<p>lazyInit：表示Bean是否是懒加载</p>
<p>initMethodName：表示Bean初始化时要执行的方法</p>
<p>destroyMethodName：表示Bean销毁时要执行的方法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BeanDefinitionTest</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-comment">//1.获取IOC容器</span><br>        <span class="hljs-type">AnnotationConfigApplicationContext</span> <span class="hljs-variable">ac</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotationConfigApplicationContext</span>();<br><br>        <span class="hljs-comment">//2.通过BeanDefinition，直接注册实例bean，至IOC容器中</span><br>        <span class="hljs-type">AbstractBeanDefinition</span> <span class="hljs-variable">beanDefinition</span> <span class="hljs-operator">=</span> BeanDefinitionBuilder.genericBeanDefinition().getBeanDefinition();<br>        <span class="hljs-comment">//指定bean定义的类类型</span><br>        beanDefinition.setBeanClass(Person.class);<br>        <span class="hljs-comment">//将bean定义，注册至IOC容器中</span><br>        ac.registerBeanDefinition(<span class="hljs-string">&quot;p&quot;</span>,beanDefinition);<br>        <span class="hljs-comment">//刷新</span><br>        ac.refresh();<br><br>        <span class="hljs-comment">//3.获取实例bean</span><br>        <span class="hljs-type">Person</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> ac.getBean(<span class="hljs-string">&quot;p&quot;</span>, Person.class);<br>        System.out.println(p);<br><br>        <span class="hljs-comment">//4.使用实例bean</span><br>        p.setUsername(<span class="hljs-string">&quot;王朝&quot;</span>);<br>        System.out.println(p.getUsername());<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure>



<h3 id="4-FactoryBean"><a href="#4-FactoryBean" class="headerlink" title="4.FactoryBean"></a>4.FactoryBean</h3><p>1.Spring 中有两种类型的 Bean, 一种是普通Bean, 另一种是工厂Bean, 即FactoryBean. </p>
<p>2.工厂 Bean 跟普通Bean不同, 其返回的对象不是指定类的一个实例, 其返回的是该工厂 Bean 的 getObject 方法所返回的对象 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component(&quot;person&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyFactoryBean</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">FactoryBean</span> &#123;<br>    <span class="hljs-comment">//返回值，即注册在IOC容器中的实例</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getObject</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>    &#125;<br><br>    <span class="hljs-comment">//返回值，即注册在IOC容器中的实例的类类型</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Class&lt;?&gt; getObjectType() &#123;<br>        <span class="hljs-keyword">return</span> Person.class;<br>    &#125;<br><br>    <span class="hljs-comment">//是否是单例  true单例</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSingleton</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure>



<blockquote>
<p>若想独立创建一个Bean，也是可以通过FactoryBean来完成。但是注意，通过这种方式创造出来的Bean，<strong>只会经过初始化后</strong>，其他Spring的生命周期步骤是不会经过的，比如依赖注入。</p>
<p>通过@Bean也可以自己生成一个对象作为Bean，那么和FactoryBean的区别是什么呢？其实在很多场景下他俩是可以替换的，但是站在原理层面来说的，区别很明显，@Bean定义的Bean是会经过完整的Bean生命周期的。</p>
</blockquote>
<h3 id="5-函数式风格GenericApplicationContext"><a href="#5-函数式风格GenericApplicationContext" class="headerlink" title="5.函数式风格GenericApplicationContext"></a>5.函数式风格GenericApplicationContext</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//函数式风格创建对象，交给 spring 进行管理</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SupplierTest</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//1.先创建IOC容器</span><br>        <span class="hljs-type">AnnotationConfigApplicationContext</span> <span class="hljs-variable">ac</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotationConfigApplicationContext</span>();<br><br>        <span class="hljs-comment">//2.注册实例bean</span><br>        <span class="hljs-comment">//刷新</span><br>        ac.refresh();<br>        <span class="hljs-comment">//函数时编程风格Supplier，注册Person的实例bean</span><br>        ac.registerBean(<span class="hljs-string">&quot;ppp&quot;</span>, Person.class , ()-&gt;<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>());<br><br>        <span class="hljs-comment">//3.获取实例bean</span><br>        System.out.println(Arrays.toString(ac.getBeanDefinitionNames()));<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> ac.getBean(<span class="hljs-string">&quot;ppp&quot;</span>, Person.class);<br>        <span class="hljs-comment">//com.igeek.config.ch01.Person@887af79</span><br>        System.out.println(person);<br><br>        <span class="hljs-comment">//4.使用实例bean</span><br>        person.setUsername(<span class="hljs-string">&quot;马汉&quot;</span>);<br>        System.out.println(person.getUsername());<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure>



<h3 id="6-总结"><a href="#6-总结" class="headerlink" title="6.总结"></a>6.总结</h3><p>在Spring中，可以通过<strong>声明式定义Bean</strong>方式：</p>
<blockquote>
<p>方式一：<bean></p>
<p>方式二：@Bean</p>
<p>方式三：@Component、@Service、@Controller、@Repository</p>
</blockquote>
<p>在Spring中，可以通过<strong>编程式定义Bean</strong>方式：</p>
<blockquote>
<p>方式一：BeanDefinition 接口</p>
<p>方式二： 自定义FactoryBean </p>
<p>方式三：函数式接口 Supplier&lt;T&gt;</p>
</blockquote>
<h2 id="2-3、Spring-IOC-XML版"><a href="#2-3、Spring-IOC-XML版" class="headerlink" title="2.3、Spring IOC XML版"></a>2.3、Spring IOC XML版</h2><h3 id="1-依赖注入的方式"><a href="#1-依赖注入的方式" class="headerlink" title="1.依赖注入的方式"></a>1.依赖注入的方式</h3><h4 id="1-属性注入"><a href="#1-属性注入" class="headerlink" title="1).属性注入"></a>1).属性注入</h4><p>1).属性注入即通过 setter 方法注入Bean 的属性值或依赖的对象</p>
<p>2).属性注入使用 <property> 元素, 使用 name 属性指定 Bean 的属性名称，value 属性或 <value> 子节点指定属性值 </p>
<p>3).属性注入是实际应用中最常用的注入方式</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- name对应的是setXxx()中的xxx value是指将为类中的属性赋值--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;helloWorld&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.igeek.spring.ch01.HelloWorld&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;userName1&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Spring&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure>



<h4 id="2-构造方法注入"><a href="#2-构造方法注入" class="headerlink" title="2).构造方法注入"></a>2).构造方法注入</h4><p>1).通过构造方法注入Bean 的属性值或依赖的对象，它保证了 Bean 实例在实例化后就可以使用。</p>
<p>2).构造器注入在 <constructor-arg> 元素里声明属性, <constructor-arg> 中没有 name 属性</p>
<p>3). </p>
<p>按<strong>索引</strong>匹配入参：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;car2&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.igeek.xml.ch02.Car&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">index</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;玛莎拉蒂&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">index</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;3000000.0&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure>



<p>按<strong>类型</strong>匹配入参：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;p2&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.igeek.xml.ch02.Person&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;java.lang.String&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;李四&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;int&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;26&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;com.igeek.xml.ch02.Car&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;car2&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure>



<h3 id="2-属性配置细节"><a href="#2-属性配置细节" class="headerlink" title="2.属性配置细节"></a>2.属性配置细节</h3><h4 id="1-字面值"><a href="#1-字面值" class="headerlink" title="1).字面值"></a>1).字面值</h4><blockquote>
<p>字面值：可用字符串表示的值，可以通过 <value> 元素标签或 value 属性进行注入。</p>
<p>基本数据类型及其封装类、String 等类型都可以采取字面值注入的方式。</p>
<p>若字面值中包含特殊字符，可以使用 &#x3D;&#x3D;<![CDATA[]]>&#x3D;&#x3D;把字面值包裹起来。</p>
</blockquote>
<p><img  src="E:/ftp%E8%B5%84%E6%96%99/note/8.SSM/1.Spring/%E8%AF%BE%E4%BB%B6/image/wps9.jpg"  ><span class="image-caption">img</span></p>
<h4 id="2-引用其它-Bean"><a href="#2-引用其它-Bean" class="headerlink" title="2).引用其它 Bean"></a>2).引用其它 Bean</h4><blockquote>
<p>1). 组成应用程序的 Bean 经常需要相互协作以完成应用程序的功能。 要使 Bean 能够相互访问, 就必须在 Bean 配置文件中指定对 Bean 的引用。</p>
<p>2). 在 Bean 的配置文件中, 可以通过 <ref> 元素或 ref属性为 Bean 的属性或构造器参数指定对 Bean 的引用。</p>
<p>3).也可以在属性或构造器里包含 Bean 的声明, 这样的 Bean 称为内部 Bean.</p>
<blockquote>
<ul>
<li>当 Bean 实例仅仅给一个特定的属性使用时, 可以将其声明为内部 Bean. 内部 Bean 声明直接包含在 <property> 或 <constructor-arg> 元素里, 不需要设置任何 id 或 name 属性</li>
<li>内部 Bean 不能使用在任何其他地方</li>
</ul>
</blockquote>
</blockquote>
<p><img  src="E:/ftp%E8%B5%84%E6%96%99/note/8.SSM/1.Spring/%E8%AF%BE%E4%BB%B6/image/1624205450396.png"  ><span class="image-caption">1624205450396</span></p>
<h4 id="3-级联属性"><a href="#3-级联属性" class="headerlink" title="3).级联属性"></a>3).级联属性</h4><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;p&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.cm.ch02.ref.Person&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;李四&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;age&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;35&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;car&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;c&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">            通过级联属性操作修改车的价格</span><br><span class="hljs-comment">            1.等价于Person对象调用了setCar(),car对象调用了setPrice()</span><br><span class="hljs-comment">            2.属性需要先初始化赋值，否则会出现异常</span><br><span class="hljs-comment">        --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;car.price&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;500000&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;c&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.cm.ch02.ref.Car&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;label&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;aodi&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;price&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;300000&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br><br></code></pre></td></tr></table></figure>

<h4 id="4-集合属性"><a href="#4-集合属性" class="headerlink" title="4).集合属性"></a>4).集合属性</h4><blockquote>
<p>1.在 Spring中可以通过一组内置的 xml 标签(例如: <list>, <set> 或 <map>) 来配置集合属性.</p>
<p>2.配置 java.util.List 类型的属性, 需要指定 <list> 标签, 在标签里包含一些元素. 这些标签可以通过 <value> 指定简单的常量值, 通过 <ref> 指定对其他 Bean 的引用. 通过<bean> 指定内置 Bean 定义. 通过 <null/> 指定空元素. </p>
<p>3.数组的定义和 List 一样, 都使用 <list></p>
<p>4.配置 java.util.Set 需要使用 <set> 标签, 定义元素的方法与 List 一样.</p>
</blockquote>
<p><img  src="E:/ftp%E8%B5%84%E6%96%99/note/8.SSM/1.Spring/%E8%AF%BE%E4%BB%B6/image/1624205680085.png"  ><span class="image-caption">1624205680085</span></p>
<blockquote>
<p>5.Java.util.Map 通过 <map> 标签定义, <map> 标签里可以使用多个 <entry> 作为子标签. 每个条目包含一个键和一个值. </p>
<p>6.必须在 <key> 标签里定义键</p>
<p>7.因为键和值的类型没有限制, 所以可以自由地为它们指定 <value>, <ref>, <bean> 或 <null> 元素. </p>
<p>8.可以将 Map 的键和值作为 <entry> 的属性定义: 简单常量使用 key 和 value 来定义; Bean 引用通过 key-ref 和 value-ref 属性定义</p>
</blockquote>
<p><img  src="E:/ftp%E8%B5%84%E6%96%99/note/8.SSM/1.Spring/%E8%AF%BE%E4%BB%B6/image/1624205700321.png"  ><span class="image-caption">1624205700321</span></p>
<blockquote>
<p>9.使用 utility scheme 定义集合</p>
<p>1).使用基本的集合标签定义集合时, 不能将集合作为独立的 Bean 定义, 导致其他 Bean 无法引用该集合, 所以无法在不同 Bean 之间共享集合.</p>
<p>2).可以使用 util schema 里的集合标签定义独立的集合 Bean. 需要注意的是, 必须在 <beans> 根元素里添加 util schema 定义</p>
</blockquote>
<p><img  src="E:/ftp%E8%B5%84%E6%96%99/note/8.SSM/1.Spring/%E8%AF%BE%E4%BB%B6/image/1624206566669.png"  ><span class="image-caption">1624206566669</span></p>
<h4 id="5-p命名空间"><a href="#5-p命名空间" class="headerlink" title="5).p命名空间"></a>5).p命名空间</h4><blockquote>
<p>1.为了简化 XML 文件的配置，越来越多的 XML 文件采用属性而非子元素配置信息。</p>
<p>2.Spring 从 2.5 版本开始引入了一个新的 p 命名空间，可以通过 <bean> 元素属性的方式配置 Bean 的属性。</p>
<p>3.使用 p 命名空间后，基于 XML 的配置方式将进一步简化</p>
</blockquote>
<p><img  src="E:/ftp%E8%B5%84%E6%96%99/note/8.SSM/1.Spring/%E8%AF%BE%E4%BB%B6/image/1624206601107.png"  ><span class="image-caption">1624206601107</span></p>
<h3 id="3-Bean的作用域"><a href="#3-Bean的作用域" class="headerlink" title="3.Bean的作用域"></a>3.Bean的作用域</h3><table>
<thead>
<tr>
<th align="center">类别</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">singleton</td>
<td align="center">在 SpringlOC容器中仅存在一个Bean实例，Bean以单实例的方式存在</td>
</tr>
<tr>
<td align="center">prototype</td>
<td align="center">每次调用getBean()时都会返回一个新的实例</td>
</tr>
<tr>
<td align="center">request</td>
<td align="center">每次HTTP请求都会创建一个新的 Bean ，该作用域仅适用于WebApplicationContext环境</td>
</tr>
<tr>
<td align="center">session</td>
<td align="center">同一个HTTP Session共享一个Bean ，不同的HTTP Session使用不同的 Bean。该作用域仅适用于WebApplicationContext环境</td>
</tr>
</tbody></table>
<blockquote>
<p>1.在 Spring 中, 可以在 <bean> 元素的 &#x3D;&#x3D;scope&#x3D;&#x3D; 属性里设置 Bean 的作用域. </p>
<p>2.默认情况下, Spring 只为每个在 IOC 容器里声明的 Bean 创建唯一一个实例, 整个 IOC 容器范围内都能共享该实例：所有后续的 getBean() 调用和 Bean 引用都将返回这个唯一的 Bean 实例.该作用域被称为 singleton, 它是所有 Bean 的默认作用域.</p>
</blockquote>
<h3 id="4-外部属性文件"><a href="#4-外部属性文件" class="headerlink" title="4.外部属性文件"></a>4.外部属性文件</h3><p>1.在类路径下新建<strong>db.properties</strong>属性文件</p>
<p><img  src="E:/ftp%E8%B5%84%E6%96%99/note/8.SSM/1.Spring/%E8%AF%BE%E4%BB%B6/image/image-20200713001742668.png"  ><span class="image-caption">image-20200713001742668</span></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><code class="hljs properties"><span class="hljs-comment">#mysql</span><br><span class="hljs-attr">db.user</span>=<span class="hljs-string">root</span><br><span class="hljs-attr">db.password</span>=<span class="hljs-string">root</span><br><span class="hljs-attr">db.url</span>=<span class="hljs-string">jdbc:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=Asia/Shanghai</span><br><span class="hljs-attr">db.driverClass</span>=<span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br><span class="hljs-attr">db.maxPoolSize</span>=<span class="hljs-string">30</span><br><span class="hljs-attr">db.minPoolSize</span>=<span class="hljs-string">3</span><br><span class="hljs-attr">db.initialPoolSize</span>=<span class="hljs-string">5</span><br><span class="hljs-attr">db.acquireIncrement</span>=<span class="hljs-string">5</span><br></code></pre></td></tr></table></figure>



<p>2.修改pom.xml文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--mysql驱动包 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.0.16<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--c3p0 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>c3p0<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>c3p0<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.9.1.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br></code></pre></td></tr></table></figure>

<p>注意：根据当前安装的mysql版本，选择合适的mysql驱动的版本号</p>
<p>3.新建spring的核心配置文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 导入外部属性文件 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context:property-placeholder</span> <span class="hljs-attr">location</span>=<span class="hljs-string">&quot;classpath:db.properties&quot;</span> /&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 配置c3p0数据连接池 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 使用外部属性文件上的key --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;db.user&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;db.password&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;jdbcUrl&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;db.url&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driverClass&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;db.driverClass&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;maxPoolSize&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;db.maxPoolSize&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;minPoolSize&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;db.minPoolSize&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;initialPoolSize&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;db.initialPoolSize&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;acquireIncrement&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;db.acquireIncrement&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br><br></code></pre></td></tr></table></figure>



<p>4.测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.cm.ch03.properties;<br><br><span class="hljs-keyword">import</span> com.mchange.v2.c3p0.ComboPooledDataSource;<br><span class="hljs-keyword">import</span> org.springframework.context.ApplicationContext;<br><span class="hljs-keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;<br><br><span class="hljs-keyword">import</span> java.sql.Connection;<br><span class="hljs-keyword">import</span> java.sql.PreparedStatement;<br><span class="hljs-keyword">import</span> java.sql.ResultSet;<br><span class="hljs-keyword">import</span> java.sql.SQLException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainTest</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br><br>        <span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">ac</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;beans_properties.xml&quot;</span>);<br>        <span class="hljs-type">ComboPooledDataSource</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> (ComboPooledDataSource)ac.getBean(<span class="hljs-string">&quot;dataSource&quot;</span>);<br>        System.out.println(pool);<br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> pool.getConnection();<br>        <span class="hljs-type">PreparedStatement</span> <span class="hljs-variable">preparedStatement</span> <span class="hljs-operator">=</span> connection.prepareStatement(<span class="hljs-string">&quot;select * name from t_user where id=?&quot;</span>);<br>        preparedStatement.setInt(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>        <span class="hljs-type">ResultSet</span> <span class="hljs-variable">resultSet</span> <span class="hljs-operator">=</span> preparedStatement.executeQuery();<br>        <span class="hljs-keyword">while</span> (resultSet.next())&#123;<br>            System.out.println(resultSet.getString(<span class="hljs-number">1</span>));<br>        &#125;<br>        connection.close();<br>        pool.close();<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure>



<h3 id="5-指定扫描包"><a href="#5-指定扫描包" class="headerlink" title="5.指定扫描包"></a>5.指定扫描包</h3><p>当在组件类上使用了特定的注解之后, 还需要在 Spring 的配置文件中声明 &lt;context:component-scan&gt;表示要去扫描哪些包：</p>
<p>1).base-package 属性指定一个需要扫描的基类包，Spring 容器将会扫描这个基类包里及其子包中的所有类.</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span><br><br>	<span class="hljs-comment">&lt;!-- 指定Spring IOC容器扫描的包 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.cm.ch04&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">context:component-scan</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span> <br><br></code></pre></td></tr></table></figure>

<p>2).当需要扫描多个包时, 可以使用逗号分隔.</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 指定Spring IOC容器扫描的包，当有多个包时，则可使用逗号隔开 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.cm.ch04 , com.cm.ch02&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">context:component-scan</span>&gt;</span><br><br></code></pre></td></tr></table></figure>

<p>3).如果仅希望扫描特定的类而非基包下的所有类，可使用 resource-pattern 属性过滤特定的类.</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 指定Spring IOC容器扫描的包，通过resource-pattern指定扫描的资源 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.cm.ch04&quot;</span> <span class="hljs-attr">resource-pattern</span>=<span class="hljs-string">&quot;entity/*&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">context:component-scan</span>&gt;</span><br><br></code></pre></td></tr></table></figure>



<p>4).<strong>&lt;context:include-filter&gt;</strong> 子节点表示要包含的目标类</p>
<p><strong>&lt;context:exclude-filter&gt;</strong> 子节点表示要排除在外的目标类</p>
<p>&lt;context:component-scan&gt;下可以拥有若干个&lt;context:include-filter&gt; 和 &lt;context:exclude-filter&gt; 子节点。</p>
<p>&lt;context:include-filter&gt;和&lt;context:exclude-filter&gt;子节点支持多种类型的过滤表达式：</p>
<table>
<thead>
<tr>
<th align="center">类别</th>
<th align="center">示例</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">annotation</td>
<td align="center">org.springframework.stereotype.Xxx</td>
<td align="center">所有标注了Xxx的类。该类型采用目标类是否标注了某个注解进行过滤</td>
</tr>
<tr>
<td align="center">assinable</td>
<td align="center">com.igeek.XxxService</td>
<td align="center">所有继承或扩展XxxService的类。该类型采用目标类是否继承或扩展某个特定类进行过滤</td>
</tr>
<tr>
<td align="center">aspectj</td>
<td align="center">com.igeek..”Service“</td>
<td align="center">所有类名以 Service结束的类及继承或扩展它们的类。该类型采用AspejctJ表达式进行过滤</td>
</tr>
<tr>
<td align="center">regex</td>
<td align="center">com.\igeek.\anno\.*</td>
<td align="center">所有com.igeek.anno包下的类。该类型采用正则表达式根据类的类名进行过滤</td>
</tr>
<tr>
<td align="center">custom</td>
<td align="center">com.igeek.XxxTypeFilter</td>
<td align="center">采用XxxTypeFilter通过代码的方式定义过滤规则。该类必须实现org.springframework.core.type.TypeFilter接口</td>
</tr>
</tbody></table>
<p><img  src="E:/ftp%E8%B5%84%E6%96%99/note/8.SSM/1.Spring/%E8%AF%BE%E4%BB%B6/image/1624207675347.png"  ><span class="image-caption">1624207675347</span></p>
<p><img  src="E:/ftp%E8%B5%84%E6%96%99/note/8.SSM/1.Spring/%E8%AF%BE%E4%BB%B6/image/1624207684616.png"  ><span class="image-caption">1624207684616</span></p>
<h3 id="6-BeanPostProcessor"><a href="#6-BeanPostProcessor" class="headerlink" title="6.BeanPostProcessor"></a>6.BeanPostProcessor</h3><p>BeanPostProcessor表示Bean的后置处理器，我们可以定义一个或多个BeanPostProcessor。</p>
<p>一个BeanPostProcessor可以在<strong>任意一个Bean</strong>的<strong>初始化之前</strong>以及<strong>初始化之后</strong>去额外的做一些用户自定义的逻辑，当然，我们可以通过判断beanName来进行针对性处理（针对某个Bean，或某部分Bean）。</p>
<p>我们可以通过定义BeanPostProcessor来干涉Spring创建Bean的过程。</p>
<h4 id="1-Spring-IOC-容器对-Bean-的生命周期进行管理的过程"><a href="#1-Spring-IOC-容器对-Bean-的生命周期进行管理的过程" class="headerlink" title="1).Spring IOC 容器对 Bean 的生命周期进行管理的过程"></a>1).Spring IOC 容器对 Bean 的生命周期进行管理的过程</h4><blockquote>
<p>1).通过构造器或工厂方法创建 Bean 实例</p>
<p>2).为 Bean 的属性设置值和对其他 Bean 的引用</p>
<p>3).调用 Bean 的初始化方法</p>
<p>4).Bean 可以使用了</p>
<p>5).当容器关闭close时, 调用 Bean 的销毁方法</p>
</blockquote>
<p>在 Bean 的声明里设置 init-method 和 destroy-method 属性, 为 Bean 指定初始化和销毁方法.</p>
<p><img  src="E:/ftp%E8%B5%84%E6%96%99/note/8.SSM/1.Spring/%E8%AF%BE%E4%BB%B6/image/1624207142631.png"  ><span class="image-caption">1624207142631</span></p>
<h4 id="2-创建-Bean-后置处理器"><a href="#2-创建-Bean-后置处理器" class="headerlink" title="2).创建 Bean 后置处理器"></a>2).创建 Bean 后置处理器</h4><blockquote>
<p>1.Bean 后置处理器允许在调用初始化方法前后对 Bean 进行额外的处理.</p>
<p>2.Bean 后置处理器对 IOC 容器里的所有 Bean 实例逐一处理, 而非单一实例. 其典型应用是: 检查 Bean 属性的正确性或根据特定的标准更改 Bean 的属性.</p>
<p>3.对Bean 后置处理器而言, 需要实现**&#x3D;&#x3D;BeanPostProcessor接口&#x3D;&#x3D;**. 在初始化方法被调用前后, Spring 将把每个 Bean 实例分别传递给上述接口的以下两个方法:</p>
</blockquote>
<p><img  src="E:/ftp%E8%B5%84%E6%96%99/note/8.SSM/1.Spring/%E8%AF%BE%E4%BB%B6/image/1624207251843.png"  ><span class="image-caption">1624207251843</span></p>
<p><img  src="E:/ftp%E8%B5%84%E6%96%99/note/8.SSM/1.Spring/%E8%AF%BE%E4%BB%B6/image/1624207264116.png"  ><span class="image-caption">1624207264116</span></p>
<p><img  src="E:/ftp%E8%B5%84%E6%96%99/note/8.SSM/1.Spring/%E8%AF%BE%E4%BB%B6/image/1624207273596.png"  ><span class="image-caption">1624207273596</span></p>
<h4 id="3-添加-Bean-后置处理器后-Bean-的生命周期"><a href="#3-添加-Bean-后置处理器后-Bean-的生命周期" class="headerlink" title="3).添加 Bean 后置处理器后 Bean 的生命周期"></a>3).添加 Bean 后置处理器后 Bean 的生命周期</h4><blockquote>
<p>1).通过构造器或工厂方法创建 Bean 实例</p>
<p>2).为 Bean 的属性设置值和对其他 Bean 的引用</p>
<p>3).将 Bean 实例传递给 Bean后置处理器的postProcessBeforeInitialization 方法</p>
<p>4).调用 Bean 的初始化方法</p>
<p>5).将 Bean 实例传递给 Bean 后置处理器的 postProcessAfterInitialization方法</p>
<p>6).Bean 可以使用了</p>
<p>7).当容器关闭时, 调用 Bean 的销毁方法</p>
</blockquote>
<h2 id="x3D-x3D-2-4、Spring-IOC-配置类-注解版-x3D-x3D"><a href="#x3D-x3D-2-4、Spring-IOC-配置类-注解版-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;2.4、Spring IOC 配置类+注解版&#x3D;&#x3D;"></a>&#x3D;&#x3D;2.4、Spring IOC 配置类+注解版&#x3D;&#x3D;</h2><blockquote>
<p>&#x3D;&#x3D;基于注解配置Bean&#x3D;&#x3D;：标识使用注解将bean配置到IOC容器中</p>
</blockquote>
<blockquote>
<p>&#x3D;&#x3D;基于注解来装配Bean的属性&#x3D;&#x3D;：让bean与bean之间发生关联关系</p>
</blockquote>
<h3 id="1-新建Java-Config的配置类"><a href="#1-新建Java-Config的配置类" class="headerlink" title="1.新建Java Config的配置类"></a>1.新建Java Config的配置类</h3><p>Spring 能够从 classpath 下自动扫描, 侦测和实例化具有特定注解的组件. </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//@ComponentScan 指定扫描包</span><br><span class="hljs-meta">@ComponentScan(basePackages = &#123;&quot;com.igeek.ch09.config&quot;&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyConfig</span> &#123;<br><br>    <span class="hljs-comment">//@Bean </span><br><br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="2-特定组件"><a href="#2-特定组件" class="headerlink" title="2.特定组件"></a>2.特定组件</h3><h4 id="2-1-基于注解配置Bean"><a href="#2-1-基于注解配置Bean" class="headerlink" title="2.1 基于注解配置Bean"></a>2.1 基于注解配置Bean</h4><blockquote>
<p>基于注解配置Bean</p>
</blockquote>
<p>@Component: 基本注解, 标识了一个受 Spring 管理的组件</p>
<p>@Repository: 标识持久层dao层组件</p>
<p>@Service: 标识服务层(业务层)组件</p>
<p>@Controller: 标识表现层组件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//@Component注解，基础注解，一旦标注此类，代表这个类，将交由spring的IOC容器管理</span><br><span class="hljs-comment">//注解，若不指定value值，则有默认的命名策略，类名首字母小写作为它的beanName</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>&#125;<br><br><span class="hljs-comment">//@Repository 标注当前类是数据交互层的类</span><br><span class="hljs-comment">//注解，若不指定value值，则有默认的命名策略，类名首字母小写作为它的beanName</span><br><span class="hljs-meta">@Repository</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserDao</span> &#123;<br>&#125;<br><br><span class="hljs-comment">//@Service 标注是一个业务逻辑层的类</span><br><span class="hljs-comment">//注解，若不指定value值，则有默认的命名策略，类名首字母小写作为它的beanName</span><br><span class="hljs-meta">@Service(value = &quot;userServiceImpl&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span>&#123;<br>&#125;<br><br><span class="hljs-comment">//@Controller 标注当前这个类是一个控制层的类</span><br><span class="hljs-comment">//注解，若不指定value值，则有默认的命名策略，类名首字母小写作为它的beanName</span><br><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span> &#123;<br>&#125;<br><br></code></pre></td></tr></table></figure>



<h4 id="2-2-基于注解来装配Bean的属性"><a href="#2-2-基于注解来装配Bean的属性" class="headerlink" title="2.2 基于注解来装配Bean的属性"></a>2.2 基于注解来装配Bean的属性</h4><blockquote>
<p>基于注解来装配Bean的属性</p>
</blockquote>
<p>@Value(“”):给属性赋值，注入简单类型的属性   @Value(value&#x3D;”abc”)private String name;</p>
<p>@Autowired：实现自动装配</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-comment">//@Value注解，相当于在xml中给属性注入值时的value属性；给简单类型的数据赋值</span><br>    <span class="hljs-meta">@Value(value = &quot;李四&quot;)</span><br>    <span class="hljs-keyword">private</span> String username;<br>    <span class="hljs-meta">@Value(&quot;22&quot;)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br>&#125;<br><br><br><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span> &#123;<br>    <span class="hljs-comment">//@Autowired  根据属性类型进行自动装配，直接在IOC容器中找到与之类型匹配的bean实例</span><br>    <span class="hljs-meta">@Autowired(required = false)</span><br>    <span class="hljs-keyword">private</span> UserService service;<br>&#125;<br><br></code></pre></td></tr></table></figure>



<h3 id="3-对于扫描到的组件-Spring-有默认的命名策略"><a href="#3-对于扫描到的组件-Spring-有默认的命名策略" class="headerlink" title="3.对于扫描到的组件, Spring 有默认的命名策略"></a>3.对于扫描到的组件, Spring 有默认的命名策略</h3><p>使用非限定类名, 第一个字母小写；也可以使用在注解中通过 value 属性值标识组件的名称。</p>
<p>value是默认的属性，所以可以将value省略不写；可以使用value属性值来标识bean在IOC容器中的id。 </p>
<blockquote>
<p>在调用AnnotationConfigApplicationContext的构造方法时：</p>
<ol>
<li>解析MyConfig.class，得到扫描路径</li>
<li>遍历扫描路径下的所有Java类，如果发现某个类上存在@Component、@Service等注解，那么Spring就把这个类记录下来，存在一个Map中，比如Map&lt;String, Class&gt;。（<strong>实际上，Spring源码中确实存在类似的这么一个Map，叫做BeanDefinitionMap</strong>）</li>
<li>Spring会根据某个规则生成当前类对应的beanName，作为key存入Map，当前类作为value</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainTest</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-comment">//创建IOC容器</span><br>        <span class="hljs-type">AnnotationConfigApplicationContext</span> <span class="hljs-variable">ac</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotationConfigApplicationContext</span>(MyConfig.class);<br><br>        <span class="hljs-comment">//获取UserController实例</span><br>        <span class="hljs-comment">//UserController userController = ac.getBean(UserController.class);</span><br>        <span class="hljs-comment">//userController.login();</span><br><br>        <span class="hljs-comment">//获取User实例</span><br>        <span class="hljs-type">User</span> <span class="hljs-variable">user1</span> <span class="hljs-operator">=</span> ac.getBean(User.class);<br>        <span class="hljs-type">User</span> <span class="hljs-variable">user2</span> <span class="hljs-operator">=</span> ac.getBean(User.class);<br>        System.out.println(user1);<br>        System.out.println(user2);<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure>



<h3 id="5-Bean的作用域"><a href="#5-Bean的作用域" class="headerlink" title="5.Bean的作用域"></a>5.Bean的作用域</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ComponentScan(basePackages = &#123;&quot;com.igeek.config.ch03&quot;&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyConfig</span> &#123;<br><br>    <span class="hljs-comment">//@Bean 注解，将当前方法的方法名作为beanName，将当前方法的返回值作为class类型</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-comment">//@Scope 注解，指定value属性，变更作用域，例如：singleton单例  prototype原型</span><br>    <span class="hljs-meta">@Scope(&quot;prototype&quot;)</span><br>    <span class="hljs-keyword">public</span> User <span class="hljs-title function_">u</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;李思思&quot;</span>,<span class="hljs-string">&quot;222&quot;</span>);<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure>



<h3 id="6-加载外部属性文件"><a href="#6-加载外部属性文件" class="headerlink" title="6.加载外部属性文件"></a>6.加载外部属性文件</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//加载外部属性文件</span><br><span class="hljs-meta">@PropertySource(&quot;db.properties&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DataSourceConfig</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@Value</span>(&quot;zs&quot;)  简单类型，直接赋字面量的值</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@Value</span>(&quot;$&#123;db.user&#125;&quot;) 通过$&#123;key&#125;，读取属性文件properties文件上的值</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> DataSource <span class="hljs-title function_">dataSource</span><span class="hljs-params">(</span><br><span class="hljs-params">            <span class="hljs-meta">@Value(&quot;$&#123;db.user&#125;&quot;)</span> String user,</span><br><span class="hljs-params">            <span class="hljs-meta">@Value(&quot;$&#123;db.password&#125;&quot;)</span> String password,</span><br><span class="hljs-params">            <span class="hljs-meta">@Value(&quot;$&#123;db.driverClass&#125;&quot;)</span> String driverClass,</span><br><span class="hljs-params">            <span class="hljs-meta">@Value(&quot;$&#123;db.url&#125;&quot;)</span> String jdbcUrl</span><br><span class="hljs-params">    )</span> <span class="hljs-keyword">throws</span> PropertyVetoException &#123;<br>        <span class="hljs-type">ComboPooledDataSource</span> <span class="hljs-variable">dataSource</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ComboPooledDataSource</span>();<br>        dataSource.setUser(user);<br>        dataSource.setPassword(password);<br>        dataSource.setDriverClass(driverClass);<br>        dataSource.setJdbcUrl(jdbcUrl);<br>        <span class="hljs-keyword">return</span> dataSource;<br>    &#125;<br><br>&#125;<br><br><br></code></pre></td></tr></table></figure>



<h3 id="7-ExcludeFilter和IncludeFilter"><a href="#7-ExcludeFilter和IncludeFilter" class="headerlink" title="7.ExcludeFilter和IncludeFilter"></a>7.ExcludeFilter和IncludeFilter</h3><p>这两个Filter是Spring扫描过程中用来过滤的。ExcludeFilter表示<strong>排除过滤器</strong>，IncludeFilter表示<strong>包含过滤器</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//例如，指定扫描com.igeek包下面的所有类，但是排除指定的类。</span><br><span class="hljs-meta">@ComponentScan(</span><br><span class="hljs-meta">    value = &quot;com.igeek&quot;,</span><br><span class="hljs-meta">	excludeFilters = &#123;</span><br><span class="hljs-meta">        @ComponentScan.Filter(</span><br><span class="hljs-meta">            type = FilterType.ASSIGNABLE_TYPE, </span><br><span class="hljs-meta">            classes = Xxx.class)</span><br><span class="hljs-meta">    &#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyConfig</span> &#123;<br>    ...<br>&#125;<br><br></code></pre></td></tr></table></figure>

<blockquote>
<p>FilterType分为：</p>
<ol>
<li>ANNOTATION：表示是否包含某个注解</li>
<li>ASSIGNABLE_TYPE：表示是否是某个类</li>
<li>ASPECTJ：表示否是符合某个Aspectj表达式</li>
<li>REGEX：表示是否符合某个正则表达式</li>
<li>CUSTOM：自定义</li>
</ol>
</blockquote>
<h3 id="8-基于注解方式实现属性注入"><a href="#8-基于注解方式实现属性注入" class="headerlink" title="8.基于注解方式实现属性注入"></a>8.基于注解方式实现属性注入</h3><h4 id="（1）-Autowired：根据属性类型进行自动装配"><a href="#（1）-Autowired：根据属性类型进行自动装配" class="headerlink" title="（1）@Autowired：根据属性类型进行自动装配"></a>（1）@Autowired：根据属性类型进行自动装配</h4><p>第一步 把 service 和 dao 对象创建，在 service 和 dao 类分别添加创建对象注解@Service和@Repository</p>
<p>第二步 在 service 注入 dao 对象，在 service 类添加 dao 类型属性，在属性上面使用注解</p>
<p><img  src="E:/ftp%E8%B5%84%E6%96%99/note/8.SSM/1.Spring/%E8%AF%BE%E4%BB%B6/image/1624207782369.png"  ><span class="image-caption">1624207782369</span></p>
<blockquote>
<p>@Autowired注解可以写在：</p>
<ol>
<li>属性上：先根据<strong>属性类型</strong>去找Bean，如果找到多个再根据<strong>属性名</strong>确定一个</li>
<li>构造方法上：先根据方法<strong>参数类型</strong>去找Bean，如果找到多个再根据<strong>参数名</strong>确定一个</li>
<li>set方法上：先根据方法<strong>参数类型</strong>去找Bean，如果找到多个再根据<strong>参数名</strong>确定一个</li>
</ol>
</blockquote>
<h4 id="（2）-Qualifier：根据名称进行注入"><a href="#（2）-Qualifier：根据名称进行注入" class="headerlink" title="（2）@Qualifier：根据名称进行注入"></a>（2）@Qualifier：根据名称进行注入</h4><p>这个@Qualifier 注解的使用，和上面@Autowired 一起使用 </p>
<p><img  src="E:/ftp%E8%B5%84%E6%96%99/note/8.SSM/1.Spring/%E8%AF%BE%E4%BB%B6/image/1624207914606.png"  ><span class="image-caption">1624207914606</span></p>
<h4 id="（3）-Resource：可以根据类型注入，可以根据名称注入"><a href="#（3）-Resource：可以根据类型注入，可以根据名称注入" class="headerlink" title="（3）@Resource：可以根据类型注入，可以根据名称注入"></a>（3）@Resource：可以根据类型注入，可以根据名称注入</h4><p><img  src="E:/ftp%E8%B5%84%E6%96%99/note/8.SSM/1.Spring/%E8%AF%BE%E4%BB%B6/image/1624207952567.png"  ><span class="image-caption">1624207952567</span></p>
<h3 id="9-BeanPostProcessor"><a href="#9-BeanPostProcessor" class="headerlink" title="9.BeanPostProcessor"></a>9.BeanPostProcessor</h3><p>BeanPostProcessor表示Bean的后置处理器，我们可以定义一个或多个BeanPostProcessor。</p>
<p>一个BeanPostProcessor可以在<strong>任意一个Bean</strong>的<strong>初始化之前</strong>以及<strong>初始化之后</strong>去额外的做一些用户自定义的逻辑，当然，我们可以通过判断beanName来进行针对性处理（针对某个Bean，或某部分Bean）。</p>
<p>我们可以通过定义BeanPostProcessor来干涉Spring创建Bean的过程。</p>
<h4 id="9-1-创建-Bean-后置处理器"><a href="#9-1-创建-Bean-后置处理器" class="headerlink" title="9.1 创建 Bean 后置处理器"></a>9.1 创建 Bean 后置处理器</h4><blockquote>
<p>1.Bean 后置处理器允许在调用初始化方法前后对 Bean 进行额外的处理.</p>
<p>2.Bean 后置处理器对 IOC 容器里的所有 Bean 实例逐一处理, 而非单一实例. 其典型应用是: 检查 Bean 属性的正确性或根据特定的标准更改 Bean 的属性.</p>
<p>3.对Bean 后置处理器而言, 需要实现**&#x3D;&#x3D;BeanPostProcessor接口&#x3D;&#x3D;**. 在初始化方法被调用前后, Spring 将把每个 Bean 实例分别传递给上述接口的以下两个方法:</p>
</blockquote>
<p><img  src="E:/ftp%E8%B5%84%E6%96%99/note/8.SSM/1.Spring/%E8%AF%BE%E4%BB%B6/image/1624207251843.png"  ><span class="image-caption">1624207251843</span></p>
<h4 id="9-2-初始化和销毁"><a href="#9-2-初始化和销毁" class="headerlink" title="9.2 初始化和销毁"></a>9.2 初始化和销毁</h4><h5 id="1-Bean指定init-method-和-destroy-method-属性"><a href="#1-Bean指定init-method-和-destroy-method-属性" class="headerlink" title="1).Bean指定init-method 和 destroy-method 属性"></a>1).Bean指定init-method 和 destroy-method 属性</h5><p>在 Bean 的声明里设置 init-method 和 destroy-method 属性, 为 Bean 指定初始化和销毁方法.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean(name = &quot;t&quot; , initMethod = &quot;init&quot; ,destroyMethod = &quot;destroy&quot;)</span><br><span class="hljs-keyword">public</span> Tiger <span class="hljs-title function_">tiger</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Tiger</span>(<span class="hljs-string">&quot;白虎&quot;</span>,<span class="hljs-string">&quot;雌&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Tiger</span> &#123;<br><br>    <span class="hljs-meta">@Value(&quot;东北虎&quot;)</span><br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-meta">@Value(&quot;雄&quot;)</span><br>    <span class="hljs-keyword">private</span> String sex;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Tiger</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Tiger()&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Tiger</span><span class="hljs-params">(String name, String sex)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.sex = sex;<br>        System.out.println(<span class="hljs-string">&quot;Tiger(String,String)&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getSex</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> sex;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setSex</span><span class="hljs-params">(String sex)</span> &#123;<br>        <span class="hljs-built_in">this</span>.sex = sex;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Tiger&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, sex=&#x27;&quot;</span> + sex + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, dog=&quot;</span> + dog +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">destroy</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot;Tiger 销毁 destroy()&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Tiger 初始化 init()&quot;</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>



<h5 id="2-Bean实现implements-InitializingBean-DisposableBean接口"><a href="#2-Bean实现implements-InitializingBean-DisposableBean接口" class="headerlink" title="2).Bean实现implements InitializingBean , DisposableBean接口"></a>2).Bean实现implements InitializingBean , DisposableBean接口</h5><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Tiger</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InitializingBean</span> , DisposableBean &#123;<br><br>    <span class="hljs-meta">@Value(&quot;东北虎&quot;)</span><br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-meta">@Value(&quot;雄&quot;)</span><br>    <span class="hljs-keyword">private</span> String sex;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Tiger</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Tiger()&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Tiger</span><span class="hljs-params">(String name, String sex)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.sex = sex;<br>        System.out.println(<span class="hljs-string">&quot;Tiger(String,String)&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getSex</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> sex;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setSex</span><span class="hljs-params">(String sex)</span> &#123;<br>        <span class="hljs-built_in">this</span>.sex = sex;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Tiger&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, sex=&#x27;&quot;</span> + sex + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, dog=&quot;</span> + dog +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//销毁方法   DisposableBean</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">destroy</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot;Tiger 销毁 destroy()&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//初始化方法  InitializingBean</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterPropertiesSet</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot;Tiger 初始化 afterPropertiesSet()&quot;</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>



<h5 id="3-Bean方法上指定注解-PostConstruct、-PreDestroy"><a href="#3-Bean方法上指定注解-PostConstruct、-PreDestroy" class="headerlink" title="3).Bean方法上指定注解@PostConstruct、@PreDestroy"></a>3).Bean方法上指定注解@PostConstruct、@PreDestroy</h5><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Tiger</span> &#123;<br><br>    <span class="hljs-meta">@Value(&quot;东北虎&quot;)</span><br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-meta">@Value(&quot;雄&quot;)</span><br>    <span class="hljs-keyword">private</span> String sex;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Tiger</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Tiger()&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Tiger</span><span class="hljs-params">(String name, String sex)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.sex = sex;<br>        System.out.println(<span class="hljs-string">&quot;Tiger(String,String)&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getSex</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> sex;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setSex</span><span class="hljs-params">(String sex)</span> &#123;<br>        <span class="hljs-built_in">this</span>.sex = sex;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Tiger&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, sex=&#x27;&quot;</span> + sex + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, dog=&quot;</span> + dog +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@PreDestroy</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">destroy</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot;Tiger 销毁 destroy()&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@PostConstruct</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Tiger 初始化 init()&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<blockquote>
<p>注意：允许以上三种情况同时出现作用</p>
<p>执行顺序：注解方式  &gt;  接口方式  &gt;  Bean指定方法</p>
</blockquote>
<h3 id="10-管理Bean的生命周期"><a href="#10-管理Bean的生命周期" class="headerlink" title="10.管理Bean的生命周期"></a>10.管理Bean的生命周期</h3><blockquote>
<p>1.BeanDefinition 生成</p>
<p>2.实例化前</p>
<p>3.推断构造方法</p>
<p>4.实例化</p>
<p>5.实例化后 </p>
<p>6.填充属性</p>
<p>7.初始化前</p>
<p>8.初始化</p>
<p>9.初始化后</p>
<p>10.销毁</p>
</blockquote>
<h1 id="三-Spring的AOP"><a href="#三-Spring的AOP" class="headerlink" title="三.Spring的AOP"></a>三.Spring的AOP</h1><h2 id="x3D-x3D-3-1、AOP-原理-x3D-x3D"><a href="#x3D-x3D-3-1、AOP-原理-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;3.1、AOP 原理&#x3D;&#x3D;"></a>&#x3D;&#x3D;3.1、AOP 原理&#x3D;&#x3D;</h2><h3 id="1-需求"><a href="#1-需求" class="headerlink" title="1.需求"></a>1.需求</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ArithmeticCalculator</span>&#123;<br>    <span class="hljs-type">double</span> <span class="hljs-title function_">add</span> <span class="hljs-params">(<span class="hljs-type">double</span> a, <span class="hljs-type">double</span> b)</span>;<br>    <span class="hljs-type">double</span> <span class="hljs-title function_">sub</span> <span class="hljs-params">(<span class="hljs-type">double</span> a, <span class="hljs-type">double</span> b)</span>;<br>    <span class="hljs-type">double</span> <span class="hljs-title function_">mul</span> <span class="hljs-params">(<span class="hljs-type">double</span> a, <span class="hljs-type">double</span> b)</span>;<br>    <span class="hljs-type">double</span> <span class="hljs-title function_">div</span> <span class="hljs-params">(<span class="hljs-type">double</span> a, <span class="hljs-type">double</span> b)</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArithmeticCalculatorImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ArithmeticCalculator</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">add</span> <span class="hljs-params">(<span class="hljs-type">double</span> a, <span class="hljs-type">double</span> b)</span>&#123;<br>        <span class="hljs-keyword">return</span> a+b;<br>    &#125;<br>     <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">sub</span> <span class="hljs-params">(<span class="hljs-type">double</span> a, <span class="hljs-type">double</span> b)</span>&#123;<br>        <span class="hljs-keyword">return</span> a-b;<br>    &#125;<br>     <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">mul</span> <span class="hljs-params">(<span class="hljs-type">double</span> a, <span class="hljs-type">double</span> b)</span>&#123;<br>        <span class="hljs-keyword">return</span> a*b;<br>    &#125;<br>     <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">div</span> <span class="hljs-params">(<span class="hljs-type">double</span> a, <span class="hljs-type">double</span> b)</span>&#123;<br>        <span class="hljs-keyword">return</span> a/b;<br>    &#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure>

<p><strong>增加需求：</strong></p>
<p>需求1-日志：在程序执行期间追踪正在发生的活动</p>
<p>需求2-验证：希望计算器只能处理正数的运算</p>
<h3 id="2-代码实现片段"><a href="#2-代码实现片段" class="headerlink" title="2.代码实现片段"></a>2.代码实现片段</h3><p>ICount 计算器接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.cm.ch05.aop;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ICount</span> &#123;<br>	<br>	<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span>;<br>	<br>	<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sub</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span>;<br>	<br>	<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">mul</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span>;<br>	<br>	<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">div</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span>;<br>&#125;<br><br><br></code></pre></td></tr></table></figure>



<p>CountImpl 计算器实现类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.cm.ch05.aop;<br><br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CountImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ICount</span>&#123;<br><br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span>&#123;<br>		System.out.println(<span class="hljs-string">&quot;add()&quot;</span>);<br>		<span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> i+j;<br>		<span class="hljs-keyword">return</span> result;<br>	&#125;<br><br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sub</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>		System.out.println(<span class="hljs-string">&quot;sub()&quot;</span>);<br>		<span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> i-j;<br>		<span class="hljs-keyword">return</span> result;<br>	&#125;<br><br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">mul</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>		System.out.println(<span class="hljs-string">&quot;mul()&quot;</span>);<br>		<span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> i*j;<br>		<span class="hljs-keyword">return</span> result;<br>	&#125;<br><br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">div</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>		System.out.println(<span class="hljs-string">&quot;div()&quot;</span>);<br>		<span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> i/j;<br>		<span class="hljs-keyword">return</span> result;<br>	&#125;<br><br>&#125; <br><br></code></pre></td></tr></table></figure>

<p>CountLogImpl 计算器日志实现类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.cm.ch05.aop;<br><br><span class="hljs-comment">//添加需求：日志跟踪</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CountLogImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ICount</span>&#123;<br><br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>		System.out.println(<span class="hljs-string">&quot;日志追踪：the method add begin with [ &quot;</span>+i+<span class="hljs-string">&quot;,&quot;</span>+j+<span class="hljs-string">&quot; ]&quot;</span>);<br>		<span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> i+j;<br>		System.out.println(<span class="hljs-string">&quot;日志追踪：the method add end with &quot;</span>+result);<br>		<span class="hljs-keyword">return</span> result;<br>	&#125;<br><br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sub</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>		System.out.println(<span class="hljs-string">&quot;日志追踪：the method sub begin with [ &quot;</span>+i+<span class="hljs-string">&quot;,&quot;</span>+j+<span class="hljs-string">&quot; ]&quot;</span>);<br>		<span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> i-j;<br>		System.out.println(<span class="hljs-string">&quot;日志追踪：the method sub end with &quot;</span>+result);<br>		<span class="hljs-keyword">return</span> result;<br>	&#125;<br><br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">mul</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>		System.out.println(<span class="hljs-string">&quot;日志追踪：the method mul begin with [ &quot;</span>+i+<span class="hljs-string">&quot;,&quot;</span>+j+<span class="hljs-string">&quot; ]&quot;</span>);<br>		<span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> i*j;<br>		System.out.println(<span class="hljs-string">&quot;日志追踪：the method mul end with &quot;</span>+result);<br>		<span class="hljs-keyword">return</span> result;<br>	&#125;<br><br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">div</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>		System.out.println(<span class="hljs-string">&quot;日志追踪：the method div begin with [ &quot;</span>+i+<span class="hljs-string">&quot;,&quot;</span>+j+<span class="hljs-string">&quot; ]&quot;</span>);<br>		<span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> i/j;<br>		System.out.println(<span class="hljs-string">&quot;日志追踪：the method div end with &quot;</span>+result);<br>		<span class="hljs-keyword">return</span> result;<br>	&#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure>



<p><strong>问题：</strong></p>
<p><strong>1.代码混乱</strong>：越来越多的非业务需求(日志和验证等)加入后, 原有的业务方法急剧膨胀.  每个方法在处理核心逻辑的同时还必须兼顾其他多个关注点. </p>
<p><strong>2.代码分散</strong>: 以日志需求为例, 只是为了满足这个单一需求, 就不得不在多个模块（方法）里多次重复相同的日志代码. 如果日志需求发生变化, 必须修改所有模块.</p>
<h3 id="3-使用动态代理解决上述问题"><a href="#3-使用动态代理解决上述问题" class="headerlink" title="3.使用动态代理解决上述问题"></a>3.使用动态代理解决上述问题</h3><p>代理设计模式的原理: 使用一个代理将对象包装起来, 然后用该代理对象取代原始对象. 任何对原始对象的调用都要通过代理. 代理对象决定是否以及何时将方法调用转到原始对象上.</p>
<p><strong>ArithmeticCalculatorLogProxy动态代理类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArithmeticCalculatorLogProxy</span> &#123;   <span class="hljs-comment">// ArithmeticCalculatorLogProxy动态代理类</span><br>    <span class="hljs-comment">//要代理的对象</span><br>    <span class="hljs-keyword">private</span> ArithmeticCalculator target;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ArithmeticCalculatorLogProxy</span><span class="hljs-params">(ArithmeticCalculator target)</span>&#123;<br>        <span class="hljs-built_in">this</span>.target = target;<br>    &#125;<br>    <span class="hljs-keyword">public</span> ArithmeticCalculator <span class="hljs-title function_">getLogProxy</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">ArithmeticCalculator</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-comment">//代理对象由哪一个类加载器负责加载</span><br>        <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">loader</span> <span class="hljs-operator">=</span> target.getClass().getClassLoader();<br>        <span class="hljs-comment">//代理对象的类型</span><br>        Class[] interfaces = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;ArithmeticCalculator.class&#125;;<br>        <span class="hljs-comment">//当调用代理对象其中的方法时，该执行的代码</span><br>        <span class="hljs-type">InvocationHandler</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvocationHandler</span>() &#123;<br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">            * proxy:正在返回的那个代理对象。一般情况下在invoke方法中不使用该对象</span><br><span class="hljs-comment">            * method:正在被调用的方法</span><br><span class="hljs-comment">            * args:调用方法时，传入的参数</span><br><span class="hljs-comment">            */</span><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>                <span class="hljs-type">String</span> <span class="hljs-variable">methodName</span> <span class="hljs-operator">=</span> method.getName();<br>                <span class="hljs-comment">//日志</span><br>                System.out.println(<span class="hljs-string">&quot;the method &quot;</span>+methodName+<span class="hljs-string">&quot; begin with &quot;</span>+Arrays.asList(args));<br>                <span class="hljs-comment">//执行方法</span><br>                <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> method.invoke(target, args);<br>                <span class="hljs-comment">//日志</span><br>                System.out.println(<span class="hljs-string">&quot;the method &quot;</span>+methodName+<span class="hljs-string">&quot; end with &quot;</span>+result);<br>                <span class="hljs-keyword">return</span> result;<br>            &#125;<br>        &#125;;<br>        proxy = (ArithmeticCalculator)Proxy.newProxyInstance(loader, interfaces, h);<br>        <span class="hljs-keyword">return</span> proxy;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p><strong>测试</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">ArithmeticCalculator</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArithmeticCalculatorImpl</span>();<br><span class="hljs-type">ArithmeticCalculator</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArithmeticCalculatorLogProxy</span>(target).getLogProxy();<br>		<br><span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> proxy.add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>System.out.println(<span class="hljs-string">&quot;--&gt;&quot;</span>+result);<br><br>result = proxy.div(<span class="hljs-number">4</span>, <span class="hljs-number">2</span>);<br>System.out.println(<span class="hljs-string">&quot;--&gt;&quot;</span>+result);<br></code></pre></td></tr></table></figure>



<h2 id="3-2、AOP-简介"><a href="#3-2、AOP-简介" class="headerlink" title="3.2、AOP 简介"></a>3.2、AOP 简介</h2><h3 id="x3D-x3D-1-AOP-Aspect-Oriented-Programming-面向切面编程-x3D-x3D"><a href="#x3D-x3D-1-AOP-Aspect-Oriented-Programming-面向切面编程-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;1.AOP(Aspect-Oriented Programming, 面向切面编程)&#x3D;&#x3D;"></a>&#x3D;&#x3D;1.AOP(Aspect-Oriented Programming, 面向切面编程)&#x3D;&#x3D;</h3><blockquote>
<p>是一种新的方法论, 是对传统 OOP(Object-Oriented Programming, 面向对象编程) 的补充.</p>
<p>AOP 的主要编程对象是&#x3D;&#x3D;切面(aspect)&#x3D;&#x3D;, 而切面&#x3D;&#x3D;模块化横切关注点&#x3D;&#x3D;.</p>
<p>在应用 AOP 编程时，仍然需要定义公共功能, 但可以明确的定义这个功能在哪里, 以什么方式应用, 并且不必修改受影响的类. 这样一来横切关注点就被模块化到特殊的对象(切面)里.</p>
</blockquote>
<h3 id="2-AOP的好处"><a href="#2-AOP的好处" class="headerlink" title="2.AOP的好处"></a>2.AOP的好处</h3><p>1). 每个事物逻辑位于一个位置, 代码不分散, 便于维护和升级</p>
<p>2). 业务模块更简洁, 只包含核心业务代码. </p>
<h3 id="3-AOP术语"><a href="#3-AOP术语" class="headerlink" title="3.AOP术语"></a>3.AOP术语</h3><p>1). &#x3D;&#x3D;切面(Aspect)&#x3D;&#x3D;:  横切关注点(跨越应用程序多个模块的功能)被模块化的类</p>
<p>2). &#x3D;&#x3D;通知(Advice)&#x3D;&#x3D;:  切面必须要完成的工作(切面中的每一个方法被称为通知)</p>
<p>3). 目标(Target): 被通知的对象</p>
<p>4). 代理(Proxy): 向目标对象应用通知之后创建的对象</p>
<p>5). &#x3D;&#x3D;连接点（Joinpoint）&#x3D;&#x3D;：程序执行的某个特定位置（一个具体的物理存在）：如类某个方法调用前、调用后、方法抛出异常后等。连接点由两个信息确定：方法表示的程序执行点；相对点表示的方位。例如 ArithmethicCalculator#add() 方法执行前的连接点，执行点为 ArithmethicCalculator#add()； 方位为该方法执行前的位置</p>
<p>6). &#x3D;&#x3D;切点（pointcut）&#x3D;&#x3D;：每个类都拥有多个连接点：例如 ArithmethicCalculator 的所有方法实际上都是连接点，即连接点是程序类中客观存在的事务。AOP 通过切点定位到特定的连接点。类比：连接点相当于数据库中的记录，切点相当于查询条件。切点和连接点不是一对一的关系，一个切点匹配多个连接点，切点通过 org.springframework.aop.Pointcut 接口进行描述，它使用类和方法作为连接点的查询条件。</p>
<h2 id="x3D-x3D-3-3、Spring-AOP-注解-配置类版-x3D-x3D"><a href="#x3D-x3D-3-3、Spring-AOP-注解-配置类版-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;3.3、Spring  AOP  注解+ 配置类版&#x3D;&#x3D;"></a>&#x3D;&#x3D;3.3、Spring  AOP  注解+ 配置类版&#x3D;&#x3D;</h2><p>1).AspectJ：Java 社区里最完整最流行的 AOP 框架.</p>
<p>2).在 Spring2.0 以上版本中, 可以使用基于 AspectJ 注解或基于 XML 配置的 AOP</p>
<h3 id="1-修改pom-xml"><a href="#1-修改pom-xml" class="headerlink" title="1.修改pom.xml"></a>1.修改pom.xml</h3><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-aop --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-aop<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.3.13<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 引入aspectj依赖 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.aspectj<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>aspectjweaver<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.9.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br></code></pre></td></tr></table></figure>



<h3 id="2-新建spring的核心配置类"><a href="#2-新建spring的核心配置类" class="headerlink" title="2.新建spring的核心配置类"></a>2.新建spring的核心配置类</h3><p>要在 Spring IOC 容器中启用 AspectJ 注解支持</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//开启Aspect面向切面编程   proxyTargetClass = true开启CGLIB动态代理</span><br><span class="hljs-meta">@EnableAspectJAutoProxy(proxyTargetClass = true)</span><br><span class="hljs-comment">//配置扫描包</span><br><span class="hljs-meta">@ComponentScan(&quot;com.igeek.aop.ch03.config&quot;)</span><br><span class="hljs-comment">//当前类是一个配置类</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyConfig</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@Bean</span> 注解</span><br><span class="hljs-comment">     * 1.将当前方法的返回值放入IOC容器进行管理</span><br><span class="hljs-comment">     * 2.无论getBean多少次，获得都是唯一的实例，因为Spring IOC容器，默认单实例</span><br><span class="hljs-comment">     * 3.当前实例放入IOC容器后，会将当前方法名作为BeanName来进行使用</span><br><span class="hljs-comment">     * 4.<span class="hljs-doctag">@Bean</span>在配置类，搭配创建组件</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-comment">//@Scope(&quot;prototype&quot;)</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> ArithmeticCalculator <span class="hljs-title function_">c</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArithmeticCalculator</span>();<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure>



<h3 id="3-用-AspectJ-注解声明切面"><a href="#3-用-AspectJ-注解声明切面" class="headerlink" title="3.用 AspectJ 注解声明切面"></a>3.用 AspectJ 注解声明切面</h3><p>1).要在 Spring 中声明 AspectJ 切面, 只需要<strong>在 IOC 容器中</strong>将切面声明为 Bean 实例. 当在 Spring IOC 容器中初始化 AspectJ 切面之后, Spring IOC 容器就会为那些与 AspectJ 切面相匹配的 Bean 创建代理.</p>
<p>2).在 AspectJ 注解中, 切面只是一个<strong>带有 @Aspect 注解</strong>的 Java 类. </p>
<p>3).通知是标注有某种注解的简单的 Java 方法.</p>
<p>4).AspectJ 支持 5 种类型的通知注解: </p>
<blockquote>
<p>@Before: 前置通知, 在方法执行之前执行</p>
<p>@After: 后置通知, 在方法执行之后执行 </p>
<p>@AfterReturning: 返回通知, 在方法返回结果之后执行</p>
<p>@AfterThrowing: 异常通知, 在方法抛出异常之后</p>
<p>@Around: 环绕通知, 围绕着方法执行</p>
</blockquote>
<h3 id="4-通知"><a href="#4-通知" class="headerlink" title="4.通知"></a>4.通知</h3><h4 id="1-前置通知"><a href="#1-前置通知" class="headerlink" title="1).前置通知"></a>1).前置通知</h4><p>在方法执行之前执行的通知，前置通知使用 <strong>@Before 注解</strong>, 并将切入点表达式的值作为注解值.</p>
<h4 id="2-后置通知"><a href="#2-后置通知" class="headerlink" title="2).后置通知"></a>2).后置通知</h4><p><strong>@After</strong>是在连接点完成之后执行的, 即连接点返回结果或者抛出异常的时候, 下面的后置通知记录了方法的终止. </p>
<h4 id="3-返回通知"><a href="#3-返回通知" class="headerlink" title="3).返回通知"></a>3).返回通知</h4><blockquote>
<p>无论连接点是正常返回还是抛出异常, 后置通知都会执行. 如果只想在连接点返回的时候记录日志, 应使用返回通知代替后置通知.</p>
<p>在返回通知中访问连接点的返回值</p>
<p>1).在返回通知中, 只要将 returning 属性添加到 <strong>@AfterReturning 注解</strong>中, 就可以访问连接点的返回值. 该属性的值即为用来传入返回值的参数名称. </p>
<p>2).必须在通知方法的签名中添加一个同名参数. 在运行时, Spring AOP 会通过这个参数传递返回值.</p>
<p>3).原始的切点表达式需要出现在 pointcut 属性中</p>
</blockquote>
<h4 id="4-异常通知"><a href="#4-异常通知" class="headerlink" title="4).异常通知"></a>4).异常通知</h4><p>1).只在连接点抛出异常时才执行异常通知</p>
<p>2).将 throwing 属性添加到 <strong>@AfterThrowing 注解</strong>中, 也可以访问连接点抛出的异常. Throwable 是所有错误和异常类的超类. 所以在异常通知方法可以捕获到任何错误和异常.</p>
<p>3).如果只对某种特殊的异常类型感兴趣, 可以将参数声明为其他异常的参数类型. 然后通知就只在抛出这个类型及其子类的异常时才被执行.</p>
<h4 id="5-环绕通知"><a href="#5-环绕通知" class="headerlink" title="5).环绕通知"></a>5).环绕通知</h4><p>1). 环绕通知**@Around**是所有通知类型中功能最为强大的, 能够全面地控制连接点. 甚至可以控制是否执行连接点. </p>
<p>2).对于环绕通知来说, 连接点的参数类型必须是 <strong>ProceedingJoinPoint</strong> . 它是 JoinPoint 的子接口, 允许控制何时执行, 是否执行连接点.</p>
<p>3).在环绕通知中需要明确调用 <strong>ProceedingJoinPoint 的 proceed() 方法</strong>来执行被代理的方法. 如果忘记这样做就会导致通知被执行了, 但目标方法没有被执行.</p>
<p>4).注意: 环绕通知的方法需要返回目标方法执行之后的结果, 即调用 joinPoint.proceed(); 的返回值, 否则会出现空指针异常</p>
<h3 id="5-利用方法签名编写-AspectJ-切入点表达式"><a href="#5-利用方法签名编写-AspectJ-切入点表达式" class="headerlink" title="5.利用方法签名编写 AspectJ 切入点表达式"></a>5.利用方法签名编写 AspectJ 切入点表达式</h3><p>1).<strong>execution * com.igeek.spring.ArithmeticCalculator.*(..)</strong>: 匹配 ArithmeticCalculator 中声明的所有方法,第一个 * 代表任意修饰符及任意返回值. 第二个 * 代表任意方法. .. 匹配任意数量的参数. 若目标类与接口与该切面在同一个包中, 可以省略包名.</p>
<p>2).execution public * ArithmeticCalculator.*(..): 匹配 ArithmeticCalculator 接口的所有公有方法.</p>
<p>3).execution public double ArithmeticCalculator.*(..): 匹配 ArithmeticCalculator 中返回 double 类型数值的方法</p>
<p>4).execution public double ArithmeticCalculator.*(double, ..): 匹配第一个参数为 double 类型的方法, .. 匹配任意数量任意类型的参数</p>
<p>5).execution public double ArithmeticCalculator.*(double, double): 匹配参数类型为 double, double 类型的方法.</p>
<h3 id="6-指定切面的优先级"><a href="#6-指定切面的优先级" class="headerlink" title="6.指定切面的优先级"></a>6.指定切面的优先级</h3><p>1).在同一个连接点上应用不止一个切面时, 除非明确指定, 否则它们的优先级是不确定的.</p>
<p>2).切面的优先级可以通过实现 Ordered 接口或利用 @Order 注解指定.</p>
<p>3).实现 Ordered 接口, getOrder() 方法的返回<strong>值越小, 优先级越高.</strong></p>
<p>4).若使用 <strong>@Order 注解</strong>, 序号出现在注解</p>
<h3 id="7-重用切入点定义"><a href="#7-重用切入点定义" class="headerlink" title="7.重用切入点定义"></a>7.重用切入点定义</h3><p>1).在编写 AspectJ 切面时, 可以直接在通知注解中书写切入点表达式. 但同一个切点表达式可能会在多个通知中重复出现.</p>
<p>2).在 AspectJ 切面中, 可以通过 <strong>@Pointcut 注解</strong>将一个切入点声明成简单的方法. 切入点的方法体通常是空的, 因为将切入点定义与应用程序逻辑混在一起是不合理的. </p>
<p>3).切入点方法的访问控制符同时也控制着这个切入点的可见性。如果切入点要在多个切面中共用, 最好将它们集中在一个公共的类中. 在这种情况下, 它们必须被声明为 public. 在引入这个切入点时, 必须将类名也包括在内. 如果类没有与这个切面放在同一个包中, 还必须包含包名.</p>
<p>4).其他通知可以通过方法名称引入该切入点.</p>
<h3 id="8-案例"><a href="#8-案例" class="headerlink" title="8.案例"></a>8.案例</h3><p>一个切面可以包括一个或者多个通知.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.cm.ch05.aop;<br><br><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">import</span> org.aspectj.lang.JoinPoint;<br><span class="hljs-keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;<br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.After;<br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.AfterReturning;<br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.AfterThrowing;<br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.Around;<br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.Aspect;<br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.Before;<br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.Pointcut;<br><span class="hljs-keyword">import</span> org.springframework.core.annotation.Order;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 日志切面</span><br><span class="hljs-comment"> * 切面:横切关注点</span><br><span class="hljs-comment"> * 1.将当前类添加到IOC容器中：@Component</span><br><span class="hljs-comment"> * 2.将当前类可以进行使用AOP：@Aspect</span><br><span class="hljs-comment"> * 3.@Order(2)  切面的优先级，数值越小越先执行</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Order(2)</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Aspect</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LogAspect</span> &#123;<br><br>	<span class="hljs-comment">//公共切入点:通过 @Pointcut 注解将一个切入点声明成简单的方法. 切入点的方法体通常是空的</span><br>	<span class="hljs-meta">@Pointcut(&quot;execution(public int com.cm.ch05.aop.CountImpl.*(int,int))&quot;)</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">declarePointcut</span><span class="hljs-params">()</span>&#123;&#125;<br><br><br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * 前置通知:@Before(&quot;execution(public int com.cm.ch05.aop.CountImpl.*(int,int))&quot;)</span><br><span class="hljs-comment">	 * 1.@Before</span><br><span class="hljs-comment">	 * 2.切点pointcut：(&quot;execution(xxx)&quot;)</span><br><span class="hljs-comment">	 * 3.简化的语法：@Before(&quot;execution(* CountImpl.*(..))&quot;)</span><br><span class="hljs-comment">	 * 第一个*：任意访问权限和任意返回值</span><br><span class="hljs-comment">	 * 第二个*：指定类下的任意方法</span><br><span class="hljs-comment">	 * 第三个..：匹配任意参数</span><br><span class="hljs-comment">	 * PS:同包下，包名可省略</span><br><span class="hljs-comment">	 * 4.JoinPoint 连接点：获得当前正在访问的方法名，参数列表</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-comment">//@Before(&quot;execution(* CountImpl.*(..))&quot;)</span><br>	<span class="hljs-meta">@Before(&quot;declarePointcut()&quot;)</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">beforeAdvice</span><span class="hljs-params">(JoinPoint jp)</span>&#123;<br>		<span class="hljs-comment">//方法名</span><br>		<span class="hljs-type">String</span> <span class="hljs-variable">methodName</span> <span class="hljs-operator">=</span> jp.getSignature().getName();<br>		<span class="hljs-comment">//参数列表</span><br>		List&lt;Object&gt; args = Arrays.asList(jp.getArgs());<br>		System.out.println(<span class="hljs-string">&quot;日志追踪：the method &quot;</span>+methodName+<span class="hljs-string">&quot; begin with &quot;</span>+args);<br>	&#125;<br><br>	<span class="hljs-comment">//返回通知:returning值的名字必须与方法中参数的形参名字一致</span><br>	<span class="hljs-comment">//@AfterReturning(pointcut=&quot;execution(* CountImpl.*(..))&quot;,returning=&quot;result&quot;)</span><br>	<span class="hljs-meta">@AfterReturning(pointcut=&quot;declarePointcut()&quot;,returning=&quot;result&quot;)</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">AfterReturningAdvice</span><span class="hljs-params">(JoinPoint jp,Object result)</span> <span class="hljs-keyword">throws</span> Throwable&#123;<br>		<span class="hljs-comment">//方法名</span><br>		<span class="hljs-type">String</span> <span class="hljs-variable">methodName</span> <span class="hljs-operator">=</span> jp.getSignature().getName();<br>		System.out.println(<span class="hljs-string">&quot;日志追踪：the method &quot;</span>+methodName+<span class="hljs-string">&quot; end with &quot;</span>+result);<br>	&#125;<br><br>	<span class="hljs-comment">//异常通知:throwing值的名字必须与方法中参数的形参名字一致</span><br>	<span class="hljs-comment">//@AfterThrowing(value=&quot;execution(* CountImpl.*(..))&quot;,throwing=&quot;ex&quot;)</span><br>	<span class="hljs-meta">@AfterThrowing(pointcut=&quot;declarePointcut()&quot;,throwing=&quot;ex&quot;)</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">AfterThrowingAdvice</span><span class="hljs-params">(JoinPoint jp,Exception ex)</span>&#123;<br>		<span class="hljs-comment">//方法名</span><br>		<span class="hljs-type">String</span> <span class="hljs-variable">methodName</span> <span class="hljs-operator">=</span> jp.getSignature().getName();<br>		System.out.println(<span class="hljs-string">&quot;日志追踪：the method &quot;</span>+methodName+<span class="hljs-string">&quot; occurn exception:&quot;</span>+ex);<br>	&#125;<br><br>	<span class="hljs-comment">//后置通知</span><br>	<span class="hljs-comment">//@After(&quot;execution(* CountImpl.*(..))&quot;)</span><br>	<span class="hljs-meta">@After(&quot;declarePointcut()&quot;)</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">AfterAdvice</span><span class="hljs-params">(JoinPoint jp)</span>&#123;<br>		<span class="hljs-comment">//方法名</span><br>		<span class="hljs-type">String</span> <span class="hljs-variable">methodName</span> <span class="hljs-operator">=</span> jp.getSignature().getName();<br>		System.out.println(<span class="hljs-string">&quot;日志追踪：the method &quot;</span>+methodName+<span class="hljs-string">&quot; end with&quot;</span>);<br>	&#125;<br><br>	<span class="hljs-comment">//环绕通知</span><br>	<span class="hljs-comment">//@Around(&quot;execution(* CountImpl.*(..))&quot;)</span><br>	<span class="hljs-keyword">public</span> Object <span class="hljs-title function_">AroundAdvice</span><span class="hljs-params">(ProceedingJoinPoint pjp)</span>&#123;<br>		<span class="hljs-type">String</span> <span class="hljs-variable">methodName</span> <span class="hljs-operator">=</span> pjp.getSignature().getName();<br>		List&lt;Object&gt; args = Arrays.asList(pjp.getArgs());<br>		<span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>		<span class="hljs-keyword">try</span> &#123;<br>			<span class="hljs-comment">//前置通知</span><br>			System.out.println(<span class="hljs-string">&quot;日志追踪：the method &quot;</span>+methodName+<span class="hljs-string">&quot; begin with &quot;</span>+args);<br>			result = pjp.proceed();<br>			<span class="hljs-comment">//返回通知</span><br>			System.out.println(<span class="hljs-string">&quot;日志追踪：the method &quot;</span>+methodName+<span class="hljs-string">&quot; end with &quot;</span>+result);<br>		&#125; <span class="hljs-keyword">catch</span> (Throwable e) &#123;<br>			<span class="hljs-comment">//环绕通知</span><br>			System.out.println(<span class="hljs-string">&quot;日志追踪：the method &quot;</span>+methodName+<span class="hljs-string">&quot; occurs exception:&quot;</span>+e.getMessage());<br>		&#125;<br>		<span class="hljs-comment">//后置通知</span><br>		System.out.println(<span class="hljs-string">&quot;日志追踪：the method &quot;</span>+methodName+<span class="hljs-string">&quot; end with&quot;</span>);<br>		<span class="hljs-keyword">return</span> result;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="9-测试"><a href="#9-测试" class="headerlink" title="9.测试"></a>9.测试</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//1.创建IOC容器  AnnotationConfigApplicationContext</span><br>        <span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">ac</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotationConfigApplicationContext</span>(MyConfig.class);<br><br>        <span class="hljs-comment">//2.获得实例bean</span><br>        <span class="hljs-type">ArithmeticCalculator</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> ac.getBean(ArithmeticCalculator.class);<br>        <span class="hljs-comment">//com.igeek.aop.ch03.config.ArithmeticCalculator$$EnhancerBySpringCGLIB$$b304c68a</span><br>        System.out.println(proxy.getClass().getName());<br><br>        <span class="hljs-comment">//3.使用实例bean</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">result1</span> <span class="hljs-operator">=</span> proxy.add(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>);<br>        System.out.println(<span class="hljs-string">&quot;result1 = &quot;</span>+result1);<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">result2</span> <span class="hljs-operator">=</span> proxy.div(-<span class="hljs-number">10</span>, <span class="hljs-number">5</span>);<br>        System.out.println(<span class="hljs-string">&quot;result2 = &quot;</span>+result2);<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure>



<h2 id="3-4、Spring-AOP-XML版"><a href="#3-4、Spring-AOP-XML版" class="headerlink" title="3.4、Spring  AOP  XML版"></a>3.4、Spring  AOP  XML版</h2><h3 id="1-基于-XML-—-声明切面"><a href="#1-基于-XML-—-声明切面" class="headerlink" title="1.基于 XML —- 声明切面"></a>1.基于 XML —- 声明切面</h3><blockquote>
<p>1.当使用 XML 声明切面时, 需要在 <beans> 根元素中导入 aop Schema</p>
<p>2.在 Bean 配置文件中, 所有的 Spring AOP 配置都必须定义在 <a href="aop:config">aop:config</a> 元素内部. 对于每个切面而言, 都要创建一个 <a href="aop:aspect">aop:aspect</a> 元素来为具体的切面实现引用后端 Bean 实例. </p>
<p>3.切面 Bean 必须有一个标示符, 供 <a href="aop:aspect">aop:aspect</a> 元素引用</p>
</blockquote>
<h3 id="2-基于-XML-—-声明切入点"><a href="#2-基于-XML-—-声明切入点" class="headerlink" title="2.基于 XML —- 声明切入点"></a>2.基于 XML —- 声明切入点</h3><blockquote>
<p>1.切入点使用<a href="aop:pointcut">aop:pointcut</a>元素声明</p>
<p>2.切入点必须定义在 <a href="aop:aspect">aop:aspect</a> 元素下, 或者直接定义在 <a href="aop:config">aop:config</a> 元素下.</p>
<p>1).定义在 <a href="aop:aspect">aop:aspect</a> 元素下: 只对当前切面有效</p>
<p>2).定义在 <a href="aop:config">aop:config</a> 元素下: 对所有切面都有效</p>
<p>3.基于 XML 的 AOP 配置不允许在切入点表达式中用名称引用其他切入点. </p>
</blockquote>
<h3 id="3-基于-XML-—-声明通知"><a href="#3-基于-XML-—-声明通知" class="headerlink" title="3.基于 XML —- 声明通知"></a>3.基于 XML —- 声明通知</h3><blockquote>
<p>1.在 aop Schema 中, 每种通知类型都对应一个特定的 XML 元素. </p>
<p>2.通知元素需要使用 <pointcut-ref> 来引用切入点, 或用 <pointcut> 直接嵌入切入点表达式.  method 属性指定切面类中通知方法的名称.</p>
</blockquote>
<h3 id="4-案例"><a href="#4-案例" class="headerlink" title="4.案例"></a>4.案例</h3><p><img  src="E:/ftp%E8%B5%84%E6%96%99/note/8.SSM/1.Spring/%E8%AF%BE%E4%BB%B6/image/1624209454641.png"  ><span class="image-caption">1624209454641</span></p>
<h1 id="四-Spring的事务管理"><a href="#四-Spring的事务管理" class="headerlink" title="四.Spring的事务管理"></a>四.Spring的事务管理</h1><h2 id="1-事务简介"><a href="#1-事务简介" class="headerlink" title="1.事务简介"></a>1.事务简介</h2><p>1).事务管理是企业级应用程序开发中必不可少的技术,  用来确保数据的完整性和一致性.</p>
<p>2).事务就是一系列的动作, 它们被当做一个单独的工作单元. 这些动作要么全部完成, 要么全部不起作用</p>
<p>3).事务的四个关键属性(ACID)</p>
<p><strong>原子性(atomicity)</strong>: 事务是一个原子操作, 由一系列动作组成. 事务的原子性确保动作要么全部完成要么完全不起作用.</p>
<p><strong>一致性(consistency)</strong>: 一旦所有事务动作完成, 事务就被提交. 数据和资源就处于一种满足业务规则的一致性状态中.</p>
<p><strong>隔离性(isolation)</strong>: 可能有许多事务会同时处理相同的数据, 因此每个事物都应该与其他事务隔离开来, 防止数据损坏.</p>
<p><strong>持久性(durability)</strong>: 一旦事务完成, 无论发生什么系统错误, 它的结果都不应该受到影响. 通常情况下, 事务的结果被写到持久化存储器中.</p>
<h2 id="2-Spring-中的事务管理"><a href="#2-Spring-中的事务管理" class="headerlink" title="2.Spring 中的事务管理"></a>2.Spring 中的事务管理</h2><p>1).作为企业级应用程序框架, Spring 在不同的事务管理 API 之上定义了一个抽象层. 而应用程序开发人员不必了解底层的事务管理 API, 就可以使用 Spring 的事务管理机制.</p>
<p>2).Spring 既支持编程式事务管理, 也支持声明式的事务管理. </p>
<p>3).编程式事务管理: 将事务管理代码嵌入到业务方法中来控制事务的提交和回滚. 在编程式管理事务时, <strong>必须在每个事务操作中包含额外的事务管理代码</strong>. </p>
<p>4).声明式事务管理: 大多数情况下比编程式事务管理更好用. 它将事务管理代码从业务方法中分离出来, 以声明的方式来实现事务管理. &#x3D;&#x3D;事务管理作为一种横切关注点, 可以<strong>通过 AOP 方法模块化</strong>&#x3D;&#x3D;. Spring 通过 Spring AOP 框架支持声明式事务管理.</p>
<h2 id="3-Spring-中的事务管理器"><a href="#3-Spring-中的事务管理器" class="headerlink" title="3.Spring 中的事务管理器"></a>3.Spring 中的事务管理器</h2><p>1.Spring 从不同的事务管理 API 中抽象了一整套的事务机制. 开发人员不必了解底层的事务 API, 就可以利用这些事务机制. 有了这些事务机制, 事务管理代码就能独立于特定的事务技术了.</p>
<p>2.Spring 的核心事务管理抽象类TransactionManager，它为事务管理封装了一组独立于技术的方法. 无论使用 Spring 的哪种事务管理策略(编程式或声明式), 事务管理器都是必须的.</p>
<p>3.<strong>DataSourceTransactionManager</strong>：在应用程序中只需要处理一个数据源, 而且通过 JDBC 存取。事务管理器以普通的 Bean 形式声明在 Spring IOC 容器中。</p>
<h2 id="x3D-x3D-4-Transactional-注解-配置类-声明式管理事务-x3D-x3D"><a href="#x3D-x3D-4-Transactional-注解-配置类-声明式管理事务-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;4.@Transactional 注解+配置类 声明式管理事务&#x3D;&#x3D;"></a>&#x3D;&#x3D;4.@Transactional 注解+配置类 声明式管理事务&#x3D;&#x3D;</h2><h3 id="4-1-修改pom-xml"><a href="#4-1-修改pom-xml" class="headerlink" title="4.1 修改pom.xml"></a>4.1 修改pom.xml</h3><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 引入spring的JDBC依赖 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-jdbc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.3.13<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--mysql驱动包 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.0.16<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--c3p0 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>c3p0<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>c3p0<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.9.1.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 单元测试 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.10<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br></code></pre></td></tr></table></figure>



<h3 id="4-2-新建spring的配置类"><a href="#4-2-新建spring的配置类" class="headerlink" title="4.2 新建spring的配置类"></a>4.2 新建spring的配置类</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//开启事务管理器  (proxyTargetClass = true)开启CGLIB动态代理</span><br><span class="hljs-meta">@EnableTransactionManagement(proxyTargetClass = true)</span><br><span class="hljs-comment">//添加扫描包</span><br><span class="hljs-meta">@ComponentScan(&quot;com.igeek.ch27.config&quot;)</span><br><span class="hljs-comment">//加载外部属性文件</span><br><span class="hljs-meta">@PropertySource(&quot;db.properties&quot;)</span><br><span class="hljs-comment">//配置类</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyConfig</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@Bean</span>   配置数据源</span><br><span class="hljs-comment">     * 1.将当前方法的返回值放入IOC容器中管理，默认singleton单例</span><br><span class="hljs-comment">     * 2.将当前方法的名称作为BeanName存入容器中</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> DataSource <span class="hljs-title function_">dataSource</span><span class="hljs-params">(</span><br><span class="hljs-params">            <span class="hljs-meta">@Value(&quot;$&#123;db.name&#125;&quot;)</span> String name,</span><br><span class="hljs-params">            <span class="hljs-meta">@Value(&quot;$&#123;db.password&#125;&quot;)</span> String password,</span><br><span class="hljs-params">            <span class="hljs-meta">@Value(&quot;$&#123;db.jdbcUrl&#125;&quot;)</span> String jdbcUrl,</span><br><span class="hljs-params">            <span class="hljs-meta">@Value(&quot;$&#123;db.driverClass&#125;&quot;)</span> String driverClass</span><br><span class="hljs-params">    )</span> <span class="hljs-keyword">throws</span> PropertyVetoException &#123;<br>        <span class="hljs-comment">//创建一个数据源</span><br>        <span class="hljs-type">ComboPooledDataSource</span> <span class="hljs-variable">dataSource</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ComboPooledDataSource</span>();<br>        <span class="hljs-comment">//将相关连接配置上</span><br>        dataSource.setUser(name);<br>        dataSource.setPassword(password);<br>        dataSource.setJdbcUrl(jdbcUrl);<br>        dataSource.setDriverClass(driverClass);<br>        <span class="hljs-comment">//返回数据源</span><br>        <span class="hljs-keyword">return</span> dataSource;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@Bean</span>  配置JdbcTemplate</span><br><span class="hljs-comment">     * 1.将当前方法的返回值放入IOC容器中管理，默认singleton单例</span><br><span class="hljs-comment">     * 2.将当前方法的名称作为BeanName存入容器中</span><br><span class="hljs-comment">     * 3.一旦方法中有形参，<span class="hljs-doctag">@Bean</span>会在IOC容器中查找到实例并注入进来</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> JdbcTemplate <span class="hljs-title function_">jdbcTemplate</span><span class="hljs-params">(DataSource dataSource)</span>&#123;<br>        <span class="hljs-type">JdbcTemplate</span> <span class="hljs-variable">jdbcTemplate</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JdbcTemplate</span>(dataSource);<br>        <span class="hljs-keyword">return</span> jdbcTemplate;<br>    &#125;<br><br><br>    <span class="hljs-comment">//将事务管理器实例放置IOC容器中管理</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> PlatformTransactionManager <span class="hljs-title function_">platformTransactionManager</span><span class="hljs-params">(DataSource dataSource)</span>&#123;<br>        <span class="hljs-type">DataSourceTransactionManager</span> <span class="hljs-variable">dataSourceTransactionManager</span> <span class="hljs-operator">=</span><br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataSourceTransactionManager</span>(dataSource);<br>        <span class="hljs-keyword">return</span> dataSourceTransactionManager;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>





<h3 id="4-3-用-Transactional-注解声明式管理事务"><a href="#4-3-用-Transactional-注解声明式管理事务" class="headerlink" title="4.3 用 @Transactional 注解声明式管理事务"></a>4.3 用 @Transactional 注解声明式管理事务</h3><p>1).除了在带有切入点, 通知和增强器的 Bean 配置文件中声明事务外, Spring 还允许简单地用 @Transactional 注解来标注事务方法.</p>
<p>2).为了将方法定义为支持事务处理的, 可以为方法添加 @Transactional 注解. 根据 Spring AOP 基于代理机制, 只能标注公有方法.</p>
<p>3).可以在方法或者类级别上添加 @Transactional 注解. 当把这个注解应用到类上时, 这个类中的所有公共方法都会被定义成支持事务处理的. </p>
<h4 id="1）、事务传播属性"><a href="#1）、事务传播属性" class="headerlink" title="1）、事务传播属性"></a>1）、事务传播属性</h4><blockquote>
<p>&#x3D;&#x3D;当事务方法被另一个事务方法调用时, 必须指定事务应该如何传播&#x3D;&#x3D;. 例如: 方法可能继续在现有事务中运行, 也可能开启一个新事务, 并在自己的事务中运行.</p>
<p>事务的传播行为可以由传播属性指定. </p>
</blockquote>
<p><img  src="E:/ftp%E8%B5%84%E6%96%99/note/8.SSM/1.Spring/%E8%AF%BE%E4%BB%B6/image/image-20200713030313168.png"  ><span class="image-caption">image-20200713030313168</span></p>
<blockquote>
<p>REQUIRED 传播行为</p>
<p>1).例如当购买方法purchase() 被另一个事务方法 checkout() 调用时, 它默认会在现有的事务内运行。这个默认的传播行为就是 REQUIRED. 因此在 checkout() 方法的开始和终止边界内只有一个事务. 这个事务只在 checkout() 方法结束的时候被提交。</p>
<p>2).事务传播属性可以在 @Transactional 注解的 propagation 属性中定义</p>
</blockquote>
<p><img  src="E:/ftp%E8%B5%84%E6%96%99/note/8.SSM/1.Spring/%E8%AF%BE%E4%BB%B6/image/image-20200713030508879.png"  ><span class="image-caption">image-20200713030508879</span></p>
<p><img  src="E:/ftp%E8%B5%84%E6%96%99/note/8.SSM/1.Spring/%E8%AF%BE%E4%BB%B6/image/wps4u6ax2.png"  ><span class="image-caption">img</span></p>
<blockquote>
<p>REQUIRES_NEW 传播行为</p>
<p>另一种常见的传播行为是 REQUIRES_NEW. 它表示该方法必须启动一个新事务, 并在自己的事务内运行. 如果有事务在运行, 就应该先挂起它.</p>
</blockquote>
<p><img  src="E:/ftp%E8%B5%84%E6%96%99/note/8.SSM/1.Spring/%E8%AF%BE%E4%BB%B6/image/wpsvszCQD.png"  ><span class="image-caption">img</span> </p>
<p><img  src="E:/ftp%E8%B5%84%E6%96%99/note/8.SSM/1.Spring/%E8%AF%BE%E4%BB%B6/image/wpsIxaTZU.png"  ><span class="image-caption">img</span></p>
<h4 id="2）、事务的隔离级别"><a href="#2）、事务的隔离级别" class="headerlink" title="2）、事务的隔离级别"></a>2）、事务的隔离级别</h4><blockquote>
<p>并发事务所导致的问题</p>
<p>1).当同一个应用程序或者不同应用程序中的多个事务在同一个数据集上并发执行时, 可能会出现许多意外的问题</p>
<p>2).并发事务所导致的问题可以分为下面三种类型:</p>
<p>脏读: 对于两个事物 T1, T2, T1  读取了已经被 T2 更新但还没有被提交的字段. 之后, 若 T2 回滚, T1读取的内容就是临时且无效的.</p>
<p>不可重复读:对于两个事物 T1, T2, T1  读取了一个字段, 然后 T2 更新了该字段. 之后, T1再次读取同一个字段, 值就不同了.</p>
<p>幻读:对于两个事物 T1, T2, T1  从一个表中读取了一个字段, 然后 T2 在该表中插入了一些新的行. 之后, 如果 T1 再次读取同一个表, 就会多出几行.</p>
</blockquote>
<p>1).从理论上来说, 事务应该彼此完全隔离, 以避免并发事务所导致的问题. 然而, 那样会对性能产生极大的影响, 因为事务必须按顺序运行. </p>
<p>2).在实际开发中, 为了提升性能, 事务会以较低的隔离级别运行.</p>
<p>3).事务的隔离级别可以通过隔离事务属性指定</p>
<p>4).Spring 支持的事务隔离级别</p>
<p><img  src="E:/ftp%E8%B5%84%E6%96%99/note/8.SSM/1.Spring/%E8%AF%BE%E4%BB%B6/image/image-20200713030831721.png"  ><span class="image-caption">image-20200713030831721</span></p>
<p>5).事务的隔离级别要得到底层数据库引擎的支持, 而不是应用程序或者框架的支持.</p>
<p>Oracle 支持的 2 种事务隔离级别：READ_COMMITED , SERIALIZABLE</p>
<p>Mysql 支持以上 4种事务隔离级别.</p>
<p>6).设置隔离事务属性</p>
<p>用 @Transactional 注解声明式地管理事务时可以在 @Transactional 的 isolation 属性中设置隔离级别.</p>
<p><img  src="E:/ftp%E8%B5%84%E6%96%99/note/8.SSM/1.Spring/%E8%AF%BE%E4%BB%B6/image/wpsjXDKhZ.png"  ><span class="image-caption">img</span></p>
<h4 id="3）、设置回滚事务属性"><a href="#3）、设置回滚事务属性" class="headerlink" title="3）、设置回滚事务属性"></a>3）、设置回滚事务属性</h4><p>1).<strong>默认情况下只有未检查异常(RuntimeException和Error类型的异常)会导致事务回滚. 而受检查异常不会.</strong></p>
<p>2).事务的回滚规则可以通过 @Transactional 注解的 <strong>rollbackFor</strong> 和 <strong>noRollbackFor</strong> 属性来定义. 这两个属性被声明为 Class[] 类型的, 因此可以为这两个属性指定多个异常类.</p>
<p>rollbackFor:  遇到时必须进行回滚</p>
<p><img  src="E:/ftp%E8%B5%84%E6%96%99/note/8.SSM/1.Spring/%E8%AF%BE%E4%BB%B6/image/wpsgqn01n.png"  ><span class="image-caption">img</span></p>
<h4 id="4）、超时和只读属性"><a href="#4）、超时和只读属性" class="headerlink" title="4）、超时和只读属性"></a>4）、超时和只读属性</h4><p>1.由于事务可以在行和表上获得锁,  因此长事务会占用资源, 并对整体性能产生影响. </p>
<p>2.如果一个事物只读取数据但不做修改, 数据库引擎可以对这个事务进行优化.</p>
<p>3.超时事务属性: timeout属性，事务在强制回滚之前可以保持多久. 这样可以防止长期运行的事务占用资源.</p>
<p>4.只读事务属性: readOnly属性为true时，表示这个事务只读取数据但不更新数据, 这样可以帮助数据库引擎优化事务.</p>
<p>5.设置超时和只读事务属性</p>
<p>超时和只读属性可以在 @Transactional 注解中定义.超时属性以秒为单位来计算.</p>
<p><img  src="E:/ftp%E8%B5%84%E6%96%99/note/8.SSM/1.Spring/%E8%AF%BE%E4%BB%B6/image/wpsW0UVa6.png"  ><span class="image-caption">img</span></p>
<h3 id="4-4-案例"><a href="#4-4-案例" class="headerlink" title="4.4 案例"></a>4.4 案例</h3><blockquote>
<p>需求：</p>
<p>1).接口BookShopDAO中:</p>
<p>&#x2F;&#x2F;根据书号获取书的单价   </p>
<p>public int  findPriceByBookId(int bookId);</p>
<p>&#x2F;&#x2F;根据书号更新书的库存,使书号对应的库存减1  </p>
<p>public void updateStock(int bookId);</p>
<p>&#x2F;&#x2F;根据用户名更新用户余额,使username的balance-price</p>
<p>public void updateAccount(String username,int price);</p>
<p>2).接口BookShopService中：</p>
<p>&#x2F;&#x2F;根据书号和用户名购买书:</p>
<p>&#x2F;&#x2F;一个用户一次只能买一本书（操作：1.账户余额减去书的单价 2.书的库存减1）</p>
<p>public void purchase(String username,int bookId);</p>
</blockquote>
<p><img  src="E:/ftp%E8%B5%84%E6%96%99/note/8.SSM/1.Spring/%E8%AF%BE%E4%BB%B6/image/1624209924680.png"  ><span class="image-caption">1624209924680</span></p>
<blockquote>
<p>导入sql文件，初始化数据：表结构创建 t_account账户表  t_book书表  t_stock书的库存表</p>
</blockquote>
<h4 id="dao层"><a href="#dao层" class="headerlink" title="dao层"></a>dao层</h4><p>IBookShopDao接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.cm.ch06.trans.dao;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IBookShopDao</span> &#123;<br><br>	<span class="hljs-comment">//根据bookId获取书的价格</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">selectPrice</span><span class="hljs-params">(<span class="hljs-type">int</span> bookId)</span>;<br>	<span class="hljs-comment">//根据bookId更新库存</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">updateStock</span><span class="hljs-params">(<span class="hljs-type">int</span> bookId)</span>;<br>	<span class="hljs-comment">//根据username,price更新账户余额</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">updateBalance</span><span class="hljs-params">(String username, <span class="hljs-type">int</span> price)</span>;<br>	<br>&#125;<br><br></code></pre></td></tr></table></figure>



<p>BookShopDaoImpl 类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.cm.ch06.trans.dao;<br><br><span class="hljs-keyword">import</span> javax.annotation.Resource;<br><br><span class="hljs-keyword">import</span> com.cm.ch06.trans.exception.AccountException;<br><span class="hljs-keyword">import</span> com.cm.ch06.trans.exception.BookStockException;<br><span class="hljs-keyword">import</span> org.springframework.jdbc.core.JdbcTemplate;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Repository;<br><br><span class="hljs-meta">@Repository(&quot;bookShopDao&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BookShopDaoImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IBookShopDao</span> &#123;<br>	<span class="hljs-meta">@Resource</span><br>	<span class="hljs-keyword">private</span> JdbcTemplate jdbcTemplate;<br>	<br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">selectPrice</span><span class="hljs-params">(<span class="hljs-type">int</span> bookId)</span> &#123;<br>		<span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;select price from t_book where bookId = ?&quot;</span>;<br>		<span class="hljs-type">Integer</span> <span class="hljs-variable">price</span> <span class="hljs-operator">=</span> jdbcTemplate.queryForObject(sql, Integer.class, bookId);<br>		<span class="hljs-keyword">return</span> price;<br>	&#125;<br><br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">updateStock</span><span class="hljs-params">(<span class="hljs-type">int</span> bookId)</span> &#123;<br>		<span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;select stock from t_stock where bookId=?&quot;</span>;<br>		<span class="hljs-type">int</span> <span class="hljs-variable">stock</span> <span class="hljs-operator">=</span> jdbcTemplate.queryForObject(s, Integer.class, bookId);<br>		<span class="hljs-keyword">if</span>(stock&lt;=<span class="hljs-number">0</span>)&#123;<br>			<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BookStockException</span>(<span class="hljs-string">&quot;库存不足!!!&quot;</span>);<br>		&#125;<br>		<br>		<span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;update t_stock set stock=stock-1 where bookId=?&quot;</span>;<br>		jdbcTemplate.update(sql, bookId);<br>	&#125;<br><br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">updateBalance</span><span class="hljs-params">(String username, <span class="hljs-type">int</span> price)</span> &#123;<br>		<span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;select balance from t_account where username=?&quot;</span>;<br>		<span class="hljs-type">Integer</span> <span class="hljs-variable">balance</span> <span class="hljs-operator">=</span> jdbcTemplate.queryForObject(s, Integer.class, username);<br>		<span class="hljs-keyword">if</span>(balance&lt;price)&#123;<br>			<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AccountException</span>(<span class="hljs-string">&quot;账户余额不足!!!&quot;</span>);<br>		&#125;<br>		<br>		<span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;update t_account set balance=balance-? where username=?&quot;</span>;<br>		jdbcTemplate.update(sql, price,username);<br>	&#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure>



<h4 id="service层"><a href="#service层" class="headerlink" title="service层"></a>service层</h4><p>ICashierService 接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.cm.ch06.trans.service;<br><br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ICashierService</span> &#123;<br><br>	<span class="hljs-comment">//客户的结账</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">cash</span><span class="hljs-params">(String username, List&lt;Integer&gt; bookIds)</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>



<p>IBookShopService 接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.cm.ch06.trans.service;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IBookShopService</span> &#123;<br><br>	<span class="hljs-comment">//通过账户名及书号购买书</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">purchase</span><span class="hljs-params">(String username, <span class="hljs-type">int</span> bookId)</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>



<p>CashierServiceImpl 类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.cm.ch06.trans.service;<br><br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">import</span> javax.annotation.Resource;<br><br><span class="hljs-keyword">import</span> org.springframework.stereotype.Service;<br><span class="hljs-keyword">import</span> org.springframework.transaction.annotation.Transactional;<br><br><span class="hljs-meta">@Service(&quot;cashierService&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CashierServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ICashierService</span> &#123;<br>	<span class="hljs-meta">@Resource</span><br>	<span class="hljs-keyword">private</span> IBookShopService bookShopService;<br>	<br>	<span class="hljs-meta">@Transactional</span><br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">cash</span><span class="hljs-params">(String username, List&lt;Integer&gt; bookIds)</span> &#123;<br>		<span class="hljs-keyword">for</span> (Integer bookId : bookIds) &#123;<br>			bookShopService.purchase(username, bookId);<br>		&#125;<br>	&#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure>



<p>BookShopServiceImpl 类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.cm.ch06.trans.service;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.sql.SQLException;<br><br><span class="hljs-keyword">import</span> javax.annotation.Resource;<br><br><span class="hljs-keyword">import</span> com.cm.ch06.trans.dao.IBookShopDao;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Service;<br><span class="hljs-keyword">import</span> org.springframework.transaction.annotation.Isolation;<br><span class="hljs-keyword">import</span> org.springframework.transaction.annotation.Propagation;<br><span class="hljs-keyword">import</span> org.springframework.transaction.annotation.Transactional;<br><br><span class="hljs-meta">@Service(&quot;bookShopService&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BookShopServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IBookShopService</span> &#123;<br>	<span class="hljs-meta">@Resource</span><br>	<span class="hljs-keyword">private</span> IBookShopDao bookShopDao;<br>	<br>	<br>	<span class="hljs-comment">//支持注解式事务管理</span><br>	<span class="hljs-meta">@Transactional(propagation=Propagation.REQUIRES_NEW,</span><br><span class="hljs-meta">			isolation=Isolation.READ_COMMITTED,</span><br><span class="hljs-meta">			rollbackFor=&#123;IOException.class,SQLException.class&#125;,</span><br><span class="hljs-meta">			noRollbackFor=&#123;ArithmeticException.class&#125;,</span><br><span class="hljs-meta">			readOnly=false,</span><br><span class="hljs-meta">			timeout=3)</span><br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">purchase</span><span class="hljs-params">(String username, <span class="hljs-type">int</span> bookId)</span> &#123;<br><span class="hljs-comment">//		try &#123;</span><br><span class="hljs-comment">//			Thread.sleep(5000);</span><br><span class="hljs-comment">//		&#125; catch (InterruptedException e) &#123;</span><br><span class="hljs-comment">//			e.printStackTrace();</span><br><span class="hljs-comment">//		&#125;</span><br>		<span class="hljs-type">int</span> <span class="hljs-variable">price</span> <span class="hljs-operator">=</span> bookShopDao.selectPrice(bookId);<br>		bookShopDao.updateStock(bookId);<br>		bookShopDao.updateBalance(username, price);<br>	&#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure>



<h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h4><p>1).只有RuntimeException的异常并且没有被try catch处理的异常才会事务回滚</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BookStockException</span> <span class="hljs-keyword">extends</span>  <span class="hljs-title class_">RuntimeException</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BookStockException</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BookStockException</span><span class="hljs-params">(String message)</span> &#123;<br>        <span class="hljs-built_in">super</span>(message);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AccountException</span> <span class="hljs-keyword">extends</span>  <span class="hljs-title class_">RuntimeException</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">AccountException</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">AccountException</span><span class="hljs-params">(String message)</span> &#123;<br>        <span class="hljs-built_in">super</span>(message);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<p>2).若异常继承了Exception，可以在service向上抛出，不要try..catch，通过以下方式指定Exception类型，可以回滚即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Transactional(rollbackFor=&#123;Exception.class&#125;)</span><br></code></pre></td></tr></table></figure>



<h4 id="测试类-TestSpringTrans"><a href="#测试类-TestSpringTrans" class="headerlink" title="测试类 TestSpringTrans"></a>测试类 TestSpringTrans</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TransactionTest</span> &#123;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">AnnotationConfigApplicationContext</span> <span class="hljs-variable">ac</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotationConfigApplicationContext</span>(MyConfig.class);<br>        <br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> ac.getBeanDefinitionCount();<br>        System.out.println(count);  <span class="hljs-comment">//17</span><br>        String[] names = ac.getBeanDefinitionNames();<br>        <span class="hljs-comment">//dataSource  jdbcTemplate  platformTransactionManager  myConfig  bookShopDaoImpl  bookShopServiceImpl</span><br>        System.out.println(Arrays.toString(names));<br>        <br>        <span class="hljs-type">BookShopServiceImpl</span> <span class="hljs-variable">service</span> <span class="hljs-operator">=</span> ac.getBean(BookShopServiceImpl.class);<br>        service.purchase(<span class="hljs-string">&quot;张三&quot;</span>,<span class="hljs-number">1</span>);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="5-Spring中使用xml文件方式配置事务"><a href="#5-Spring中使用xml文件方式配置事务" class="headerlink" title="5.Spring中使用xml文件方式配置事务"></a>5.Spring中使用xml文件方式配置事务</h2><h3 id="5-1-用事务通知声明式地管理事务"><a href="#5-1-用事务通知声明式地管理事务" class="headerlink" title="5.1 用事务通知声明式地管理事务"></a>5.1 用事务通知声明式地管理事务</h3><p>1).事务管理是一种横切关注点</p>
<p>2).为了在 Spring 2.x 中启用声明式事务管理, 可以通过 tx Schema 中定义的<a href="tx:advice">tx:advice</a> 元素声明事务通知, 为此必须事先将这个 Schema 定义添加到 <beans> 根元素中去.</p>
<p>3).声明了事务通知后, 就需要将它与切入点关联起来. 由于事务通知是在 <a href="aop:config">aop:config</a> 元素外部声明的, 所以它无法直接与切入点产生关联. 所以必须在 <a href="aop:config">aop:config</a> 元素中声明一个增强器通知与切入点关联起来.</p>
<p>4).由于 Spring AOP 是基于代理的方法, 所以只能增强公共方法. 因此, 只有公有方法才能通过 Spring AOP 进行事务管理.</p>
<h3 id="5-2-用事务通知声明式地管理事务示例代码"><a href="#5-2-用事务通知声明式地管理事务示例代码" class="headerlink" title="5.2 用事务通知声明式地管理事务示例代码"></a>5.2 用事务通知声明式地管理事务示例代码</h3><p><img  src="E:/ftp%E8%B5%84%E6%96%99/note/8.SSM/1.Spring/%E8%AF%BE%E4%BB%B6/image/1624210226913.png"  ><span class="image-caption">1624210226913</span></p>
<p><img  src="E:/ftp%E8%B5%84%E6%96%99/note/8.SSM/1.Spring/%E8%AF%BE%E4%BB%B6/image/1624210239022.png"  ><span class="image-caption">1624210239022</span></p>
<h3 id="5-3-在事务通知中-可以在-tx-method-元素中配置传播属性"><a href="#5-3-在事务通知中-可以在-tx-method-元素中配置传播属性" class="headerlink" title="5.3 在事务通知中, 可以在 tx:method 元素中配置传播属性"></a>5.3 在事务通知中, 可以在 <a href="tx:method">tx:method</a> 元素中配置传播属性</h3><p><img  src="E:/ftp%E8%B5%84%E6%96%99/note/8.SSM/1.Spring/%E8%AF%BE%E4%BB%B6/image/1624210263240.png"  ><span class="image-caption">1624210263240</span></p>
<h3 id="5-4-在事务通知中-可以在-tx-method-元素中指定隔离级别"><a href="#5-4-在事务通知中-可以在-tx-method-元素中指定隔离级别" class="headerlink" title="5.4 在事务通知中, 可以在 tx:method 元素中指定隔离级别"></a>5.4 在事务通知中, 可以在 <a href="tx:method">tx:method</a> 元素中指定隔离级别</h3><p><img  src="E:/ftp%E8%B5%84%E6%96%99/note/8.SSM/1.Spring/%E8%AF%BE%E4%BB%B6/image/1624210283686.png"  ><span class="image-caption">1624210283686</span></p>
<h3 id="5-5-在事务通知中-可以在-tx-method-元素中设置回滚事务属性"><a href="#5-5-在事务通知中-可以在-tx-method-元素中设置回滚事务属性" class="headerlink" title="5.5 在事务通知中, 可以在 tx:method 元素中设置回滚事务属性"></a>5.5 在事务通知中, 可以在 <a href="tx:method">tx:method</a> 元素中设置回滚事务属性</h3><p>如果有不止一种异常, 用逗号分隔.</p>
<p><img  src="E:/ftp%E8%B5%84%E6%96%99/note/8.SSM/1.Spring/%E8%AF%BE%E4%BB%B6/image/1624210311953.png"  ><span class="image-caption">1624210311953</span></p>
<h3 id="5-6-在事务通知中-在-tx-method-元素中设置超时和只读属性"><a href="#5-6-在事务通知中-在-tx-method-元素中设置超时和只读属性" class="headerlink" title="5.6 在事务通知中, 在 tx:method 元素中设置超时和只读属性"></a>5.6 在事务通知中, 在 <a href="tx:method">tx:method</a> 元素中设置超时和只读属性</h3><p><img  src="E:/ftp%E8%B5%84%E6%96%99/note/8.SSM/1.Spring/%E8%AF%BE%E4%BB%B6/image/1624210329897.png"  ><span class="image-caption">1624210329897</span></p>
<h1 id="五-Spring5-新特性介绍"><a href="#五-Spring5-新特性介绍" class="headerlink" title="五.Spring5 新特性介绍"></a>五.Spring5 新特性介绍</h1><h2 id="一-Spring-FrameWork-5-0新的功能"><a href="#一-Spring-FrameWork-5-0新的功能" class="headerlink" title="一.Spring FrameWork 5.0新的功能"></a>一.Spring FrameWork 5.0新的功能</h2><p>升级到新版本的框架可以参考。<a href="https://github.com/spring-projects/spring-framework/wiki/Migrating-from-earlier-versions-of-the-Spring-Framework">Spring git</a>。</p>
<h3 id="1-JDK-8-和Java-EE7-以上版本"><a href="#1-JDK-8-和Java-EE7-以上版本" class="headerlink" title="1.JDK 8+和Java EE7+以上版本"></a>1.JDK 8+和Java EE7+以上版本</h3><ul>
<li>整个框架的代码基于java8</li>
<li>通过使用泛型等特性提高可读性</li>
<li>对java8提高直接的代码支撑</li>
<li>运行时兼容JDK9</li>
<li>Java EE 7API需要Spring相关的模块支持</li>
<li>运行时兼容Java EE8 API</li>
<li>取消的包,类和方法</li>
<li>包 beans.factory.access</li>
<li>包 dbc.support.nativejdbc</li>
<li>从spring-aspects 模块移除了包mock.staicmock,不在提AnnotationDrivenStaticEntityMockingControl支持</li>
<li>许多不建议使用的类和方法在代码库中删除</li>
</ul>
<h3 id="2-核心特性"><a href="#2-核心特性" class="headerlink" title="2.核心特性"></a>2.核心特性</h3><p>JDK8的增强：</p>
<ul>
<li>访问Resuouce时提供getFile或和isFile防御式抽象</li>
<li>有效的方法参数访问基于java 8反射增强</li>
<li>在Spring核心接口中增加了声明default方法的支持一贯使用JDK7 Charset和StandardCharsets的增强</li>
<li>兼容JDK9</li>
<li>Spring 5.0框架自带了通用的日志封装</li>
<li>持续实例化via构造函数(修改了异常处理)</li>
<li>Spring 5.0框架自带了通用的日志封装</li>
<li>spring-jcl替代了通用的日志，仍然支持可重写</li>
<li>自动检测log4j2.xml, SLF4J, JUL（java.util.Logging）而不是其他的支持</li>
<li>访问Resuouce时提供getFile或和isFile防御式抽象</li>
<li>基于NIO的readableChannel也提供了这个新特性</li>
</ul>
<h3 id="3-核心容器"><a href="#3-核心容器" class="headerlink" title="3.核心容器"></a>3.核心容器</h3><ul>
<li>支持候选组件索引(也可以支持环境变量扫描)</li>
<li>支持@Nullable注解</li>
<li>函数式风格GenericApplicationContext&#x2F;AnnotationConfigApplicationContext</li>
<li>基本支持bean API注册</li>
<li>在接口层面使用CGLIB动态代理的时候，提供事物，缓存，异步注解检测</li>
<li>XML配置作用域流式</li>
<li>Spring WebMVC</li>
<li>全部的Servlet 3.1 签名支持在Spring-provied Filter实现</li>
<li>在Spring MVC Controller方法里支持Servlet4.0 PushBuilder参数</li>
<li>多个不可变对象的数据绑定(Kotlin&#x2F;Lombok&#x2F;@ConstructorPorties)</li>
<li>支持jackson2.9</li>
<li>支持JSON绑定API</li>
<li>支持protobuf3</li>
<li>支持Reactor3.1 Flux和Mono</li>
</ul>
<h3 id="4-SpringWebFlux"><a href="#4-SpringWebFlux" class="headerlink" title="4.SpringWebFlux"></a>4.SpringWebFlux</h3><ul>
<li>新的spring-webflux模块，一个基于reactive的spring-webmvc，完全的异步非阻塞，旨在使用enent-loop执行模型和传统的线程池模型。</li>
<li>Reactive说明在spring-core比如编码和解码</li>
<li>spring-core相关的基础设施，比如Encode 和Decoder可以用来编码和解码数据流；DataBuffer 可以使用java ByteBuffer或者Netty ByteBuf;ReactiveAdapterRegistry可以对相关的库提供传输层支持。</li>
<li>在spring-web包里包含HttpMessageReade和HttpMessageWrite</li>
</ul>
<h3 id="5-测试方面的改进"><a href="#5-测试方面的改进" class="headerlink" title="5.测试方面的改进"></a>5.测试方面的改进</h3><ul>
<li>完成了对JUnit 5’s Juptier编程和拓展模块在Spring TestContext框架</li>
<li>SpringExtension:是JUnit多个可拓展API的一个实现，提供了对现存Spring TestContext Framework的支持，使用@ExtendWith(SpringExtension.class)注解引用。</li>
<li>@SpringJunitConfig:一个复合注解</li>
<li>@ExtendWith(SpringExtension.class) 来源于Junit Jupit</li>
<li>@ContextConfiguration 来源于Spring TestContext框架</li>
<li>@DisabledIf 如果提供的该属性值为true的表达或占位符，信号：注解的测试类或测试方法被禁用</li>
<li>在Spring TestContext框架中支持并行测试</li>
<li>具体细节查看Test 章节 通过SpringRunner在Sring TestContext框架中支持TestNG, Junit5,新的执行之前和之后测试回调。</li>
<li>在testexecutionlistener API和testcontextmanager新beforetestexecution()和aftertestexecution()回调。MockHttpServletRequest新增了getContentAsByteArray()和getContentAsString()方法来访问请求体</li>
<li>如果字符编码被设置为mock请求，在print()和log()方法中可以打印Spring MVC Test的redirectedUrl()和forwardedUrl()方法支持带变量表达式URL模板。</li>
<li>XMLUnit 升级到了2.3版本。</li>
</ul>
<h2 id="二-新功能的使用"><a href="#二-新功能的使用" class="headerlink" title="二.新功能的使用"></a>二.新功能的使用</h2><p>整个 Spring5 框架的代码基于 Java8，运行时兼容 JDK9，许多不建议使用的类和方法在代码库中删除</p>
<h3 id="1-Spring-5-0-框架自带了通用的日志封装"><a href="#1-Spring-5-0-框架自带了通用的日志封装" class="headerlink" title="1.Spring 5.0 框架自带了通用的日志封装"></a>1.Spring 5.0 框架自带了通用的日志封装</h3><p>（1）Spring5 已经移除 Log4jConfigListener，官方建议使用 Log4j2 </p>
<p>（2）Spring5 框架整合 Log4j2</p>
<p><strong>第一步：修改pom.xml，引入依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 引入 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>log4j-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.11.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>log4j-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.11.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.7.30<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>log4j-slf4j-impl<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.11.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>



<p><strong>第二步 创建 log4j2.xml 配置文件</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-comment">&lt;!--日志级别以及优先级排序: OFF &gt; FATAL &gt; ERROR &gt; WARN &gt; INFO &gt; DEBUG &gt; TRACE &gt; </span><br><span class="hljs-comment">ALL --&gt;</span><br><span class="hljs-comment">&lt;!--Configuration 后面的 status 用于设置 log4j2 自身内部的信息输出，可以不设置，</span><br><span class="hljs-comment">当设置成 trace 时，可以看到 log4j2 内部各种详细输出--&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span> <span class="hljs-attr">status</span>=<span class="hljs-string">&quot;INFO&quot;</span>&gt;</span><br>     <span class="hljs-comment">&lt;!--先定义所有的 appender--&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">appenders</span>&gt;</span><br>         <span class="hljs-comment">&lt;!--输出日志信息到控制台--&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">console</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;Console&quot;</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;SYSTEM_OUT&quot;</span>&gt;</span><br>             <span class="hljs-comment">&lt;!--控制日志输出的格式--&gt;</span><br>             <span class="hljs-tag">&lt;<span class="hljs-name">PatternLayout</span> <span class="hljs-attr">pattern</span>=<span class="hljs-string">&quot;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%t] %-</span></span><br><span class="hljs-string"><span class="hljs-tag">        5level %logger&#123;36&#125; - %msg%n&quot;</span>/&gt;</span><br>         <span class="hljs-tag">&lt;/<span class="hljs-name">console</span>&gt;</span><br>     <span class="hljs-tag">&lt;/<span class="hljs-name">appenders</span>&gt;</span><br> <span class="hljs-comment">&lt;!--然后定义 logger，只有定义 logger 并引入的 appender，appender 才会生效--&gt;</span><br> <span class="hljs-comment">&lt;!--root：用于指定项目的根日志，如果没有单独指定 Logger，则会使用 root 作为</span><br><span class="hljs-comment">默认的日志输出--&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">loggers</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">root</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;info&quot;</span>&gt;</span><br>    	 <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;Console&quot;</span>/&gt;</span><br>     <span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">loggers</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure>



<p><strong>第三步 编写测试类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.slf4j.Logger;<br><span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LogTest</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(LogTest.class);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        logger.info(<span class="hljs-string">&quot;LogTest info级别&quot;</span>);<br>        logger.warn(<span class="hljs-string">&quot;LogTest warn级别&quot;</span>);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="2-Spring5框架核心容器支持-Nullable注解"><a href="#2-Spring5框架核心容器支持-Nullable注解" class="headerlink" title="2.Spring5框架核心容器支持@Nullable注解"></a>2.Spring5框架核心容器支持@Nullable注解</h3><p>（1）@Nullable 注解可以使用在方法上面，属性上面，参数上面，表示方法返回可以为空，属性值可以 </p>
<p>为空，参数值可以为空 </p>
<p>（2）注解用在方法上面，方法返回值可以为空</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Nullable</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">getId</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure>

<p>（3）注解使用在方法参数里面，方法参数可以为空</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">regist</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> String name)</span>&#123;<br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>（4）注解使用在属性上面，属性值可以为空</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Nullable</span><br><span class="hljs-keyword">private</span> String name;<br></code></pre></td></tr></table></figure>



<h3 id="3-Spring5支持整合JUnit5"><a href="#3-Spring5支持整合JUnit5" class="headerlink" title="3.Spring5支持整合JUnit5"></a>3.Spring5支持整合JUnit5</h3><h4 id="3-1-Spring5整合JUnit4"><a href="#3-1-Spring5整合JUnit4" class="headerlink" title="3.1 Spring5整合JUnit4"></a>3.1 Spring5整合JUnit4</h4><p><strong>第一步 修改pom.xml，添加spring-test依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-test --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.3.13<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.12<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>



<p><strong>第二步 创建测试类，使用注解方式完成</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.junit.Test;<br><span class="hljs-keyword">import</span> org.junit.runner.RunWith;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.test.context.ContextConfiguration;<br><span class="hljs-keyword">import</span> org.springframework.test.context.junit4.SpringJUnit4ClassRunner;<br><br><span class="hljs-comment">//JUnit4版本</span><br><span class="hljs-meta">@RunWith(SpringJUnit4ClassRunner.class)</span><br><span class="hljs-meta">@ContextConfiguration(&quot;classpath:spring.xml&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JTest4</span> &#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="3-2-Spring5整合JUnit5"><a href="#3-2-Spring5整合JUnit5" class="headerlink" title="3.2 Spring5整合JUnit5"></a>3.2 Spring5整合JUnit5</h4><p><strong>第一步 修改pom.xml，添加JUnit5依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.junit.jupiter/junit-jupiter-api --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.junit.jupiter<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit-jupiter-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.7.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>



<p><strong>第二步 创建测试类，使用注解完成</strong> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.junit.jupiter.api.Test;<br><span class="hljs-keyword">import</span> org.junit.jupiter.api.extension.ExtendWith;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.test.context.ContextConfiguration;<br><span class="hljs-keyword">import</span> org.springframework.test.context.junit.jupiter.SpringExtension;<br><br><span class="hljs-comment">//JUnit5版本</span><br><span class="hljs-meta">@ExtendWith(SpringExtension.class)</span><br><span class="hljs-meta">@ContextConfiguration(&quot;classpath:spring.xml&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JTest5</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="3-3-使用一个复合注解替代上面两个注解完成整合"><a href="#3-3-使用一个复合注解替代上面两个注解完成整合" class="headerlink" title="3.3 使用一个复合注解替代上面两个注解完成整合"></a>3.3 使用一个复合注解替代上面两个注解完成整合</h4><p><strong>可以使用组合注解@SpringJUnitConfig</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.junit.jupiter.api.Test;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.test.context.junit.jupiter.SpringJUnitConfig;<br><br><span class="hljs-comment">//JUnit5版本，locations属性，指定spring的配置文件</span><br><span class="hljs-meta">@SpringJUnitConfig(locations = &quot;classpath:spring.xml&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JTest5</span> &#123;<br><br>&#125;<br><br><span class="hljs-comment">//classes属性，指定spring的配置类</span><br><span class="hljs-meta">@SpringJUnitConfig(classes = MyConfig.classs)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Junit5Test</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> User user;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">//User&#123;name = 李四, pwd = 123&#125;</span><br>        System.out.println(user);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
  </entry>
</search>
